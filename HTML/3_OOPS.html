<h1>Object Oriented Programming (OOPs)</h1>
<p><a href="https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/">https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/</a></p>
<p><strong>&nbsp;</strong></p>
<p><strong>Why is Java called the &lsquo;Platform Independent Programming Language&rsquo;?</strong><br /> &nbsp;</p>
<p>Platform independence means that execution of your program does not dependent on type of operating system(it could be any : Linux, windows, Mac ..etc). So compile code only once and run it on any System (In C/C++, we need to compile the code for every machine on which we run it). Java is both compiler(javac) and interpreter(jvm) based lauguage. Your java source code is first compiled into byte code using javac compiler. This byte code can be easily converted to equivalent machine code using JVM. JVM(Java Virtual Machine) is available in all operating systems we install. Hence, byte code generated by javac is universal and can be converted to machine code on any operating system, this is the reason why java is platform independent.</p>
<p><strong>Object-oriented programming:</strong>&nbsp;As the name suggests, Object-Oriented Programming or OOPs refers to languages that uses objects in programming. Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism etc in programming. The main aim of OOP is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.</p>
<p><strong>OOPs Concepts:</strong></p>
<ul>
<li><a href="https://www.geeksforgeeks.org/polymorphism-in-java/">Polymorphism</a></li>
<li><a href="https://www.geeksforgeeks.org/inheritance-in-java/">Inheritance</a></li>
<li><a href="https://www.geeksforgeeks.org/encapsulation-in-java/">Encapsulation</a></li>
<li><a href="https://www.geeksforgeeks.org/abstraction-in-java-2/">Abstraction</a></li>
<li><a href="https://www.geeksforgeeks.org/classes-objects-java/">Class</a></li>
<li><a href="https://www.geeksforgeeks.org/classes-objects-java/">Object</a></li>
<li><a href="https://www.geeksforgeeks.org/methods-in-java/">Method</a></li>
<li><a href="https://www.geeksforgeeks.org/message-passing-in-java/">Message Passing</a></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>Polymorphism in Java</h1>
<p><a href="https://www.geeksforgeeks.org/polymorphism-in-java/">https://www.geeksforgeeks.org/polymorphism-in-java/</a></p>
<p>The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.</p>
<p><strong>Real life example of polymorphism:</strong>&nbsp;A person at the same time can have different characteristic. Like a man at the same time is a father, a husband, an employee. So the same person posses different behaviour in different situations. This is called polymorphism.</p>
<p>Polymorphism is considered as one of the important features of Object Oriented Programming. Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations. The word &ldquo;poly&rdquo; means many and &ldquo;morphs&rdquo; means forms, So it means many forms.</p>
<p><strong>In Java polymorphism is mainly divided into two types:</strong></p>
<ul>
<li>Compile time Polymorphism</li>
<li>Runtime Polymorphism</li>
</ul>
<p>&nbsp;</p>
<ol>
<li><strong>Compile time polymorphism</strong>: It is also known as static polymorphism. This type of polymorphism is achieved by function overloading or operator overloading.</li>
</ol>
<p><strong>Method Overloading</strong>: When there are multiple functions with same name but different parameters then these functions are said to be&nbsp;<strong>overloaded</strong>. Functions can be overloaded by&nbsp;<strong>change in number of arguments</strong>&nbsp;or/and&nbsp;<strong>change in type of arguments</strong>.</p>
<p><strong>Operator Overloading</strong>: Java also provide option to overload operators. For example, we can make the operator (&lsquo;+&rsquo;) for string class to concatenate two strings. We know that this is the addition operator whose task is to add two operands. So a single operator &lsquo;+&rsquo; when placed between integer operands, adds them and when placed between string operands, concatenates them.</p>
<p>In java, Only &ldquo;+&rdquo; operator can be overloaded:</p>
<ul>
<li>To add integers</li>
<li>To concatenate strings</li>
</ul>
<p>&nbsp;</p>
<ol start="2">
<li><a href="https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/"><strong>Runtime polymorphism</strong></a>: It is also known as Dynamic Method Dispatch. It is a process in which a function call to the overridden method is resolved at Runtime. This type of polymorphism is achieved by Method Overriding.</li>
</ol>
<p><strong><u>&nbsp;</u></strong></p>
<p><a href="https://www.geeksforgeeks.org/overriding-in-java/"><strong>Method overriding</strong></a>, on the other hand, occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be&nbsp;<strong>overridden</strong>.</p>
<p>&nbsp;</p>
<p><strong>Method Overloading</strong>&nbsp; <a href="https://www.geeksforgeeks.org/different-ways-method-overloading-java/">https://www.geeksforgeeks.org/different-ways-method-overloading-java/</a></p>
<p><a href="https://www.scientecheasy.com/2019/02/method-overloading-in-java.html/">https://www.scientecheasy.com/2019/02/method-overloading-in-java.html/</a></p>
<p><strong>Method overriding </strong><a href="https://www.geeksforgeeks.org/overriding-in-java/">https://www.geeksforgeeks.org/overriding-in-java/</a></p>
<h1>Access Modifiers in Java</h1>
<p><a href="https://www.geeksforgeeks.org/access-modifiers-java/">https://www.geeksforgeeks.org/access-modifiers-java/</a></p>
<h1>Inheritance in Java</h1>
<p><a href="https://www.geeksforgeeks.org/inheritance-in-java/">https://www.geeksforgeeks.org/inheritance-in-java/</a></p>
<p>&nbsp;</p>
<p>Inheritance is an important pillar of OOP(Object Oriented Programming). It is the mechanism in java by which one class is allow to inherit the features(fields and methods) of another class.<br /> <strong>Important terminology:</strong></p>
<ul>
<li><strong>Super Class:&nbsp;</strong>The class whose features are inherited is known as super class(or a base class or a parent class).</li>
<li><strong>Sub Class:</strong>The class that inherits the other class is known as sub class(or a derived class, extended class, or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.</li>
<li><strong>Reusability:&nbsp;</strong>Inheritance supports the concept of &ldquo;reusability&rdquo;, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class. By doing this, we are reusing the fields and methods of the existing class.</li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>Types of Inheritance in Java</strong></p>
<p>Below are the different types of inheritance which is supported by Java.</p>
<ol>
<li><strong>Single Inheritance :&nbsp;</strong>In single inheritance, subclasses inherit the features of one superclass. In image below, the class A serves as a base class for the derived class B.</li>
<li><strong>Multilevel Inheritance :&nbsp;</strong>In Multilevel Inheritance, a derived class will be inheriting a base class and as well as the derived class also act as the base class to other class. In below image, the class A serves as a base class for the derived class B, which in turn serves as a base class for the derived class C. In Java, a class cannot directly access the<a href="https://www.geeksforgeeks.org/g-fact-91/">grandparent&rsquo;s members</a>.</li>
<li><strong>Hierarchical Inheritance :&nbsp;</strong>In Hierarchical Inheritance, one class serves as a superclass (base class) for more than one sub class.In below image, the class A serves as a base class for the derived class B,C and D.</li>
<li><a href="https://www.geeksforgeeks.org/java-and-multiple-inheritance/"><strong>Multiple Inheritance</strong></a><strong>(Through Interfaces) :&nbsp;</strong>In Multiple inheritance ,one class can have more than one superclass and inherit features from all parent classes. Please note that Java does&nbsp;<strong>not</strong>&nbsp;support&nbsp;<a href="https://www.geeksforgeeks.org/java-and-multiple-inheritance/">multiple inheritance</a>&nbsp;with classes. In java, we can achieve multiple inheritance only through&nbsp;<a href="http://quiz.geeksforgeeks.org/interfaces-in-java/">Interfaces</a>. In image below, Class C is derived from interface A and B</li>
<li><strong>Hybrid Inheritance(Through Interfaces) :&nbsp;</strong>It is a mix of two or more of the above types of inheritance. Since java doesn&rsquo;t support multiple inheritance with classes, the hybrid inheritance is also not possible with classes. In java, we can achieve hybrid inheritance only through&nbsp;<a href="http://quiz.geeksforgeeks.org/interfaces-in-java/">Interfaces</a>.</li>
</ol>
<p>&nbsp;</p>
<p><strong>&nbsp;</strong></p>
<h1>Encapsulation in Java</h1>
<p><a href="https://www.geeksforgeeks.org/encapsulation-in-java/">https://www.geeksforgeeks.org/encapsulation-in-java/</a> <a href="https://www.javacodegeeks.com/2013/04/the-three-greatest-paragraphs-ever-written-on-encapsulation.html"><br /> Encapsulation</a>&nbsp;provides objects with the ability to hide their internal characteristics and behavior. Each object provides a number of methods, which can be accessed by other objects and change its internal data.</p>
<p>Encapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates.Other way to think about encapsulation is, it is a protective shield that prevents the data from being accessed by the code outside this shield.</p>
<ul>
<li>Encapsulation can be achieved by: Declaring all the variables in the class as private and writing public methods in the class to set and get the values of variables.</li>
</ul>
<p><strong>Advantages of Encapsulation</strong>:</p>
<ul>
<li><strong>Data Hiding:</strong>The user will have no idea about the inner implementation of the class. It will not be visible to the user that how the class is storing values in the variables. He only knows that we are passing the values to a setter method and variables are getting initialized with that value.</li>
<li><strong>Increased Flexibility:</strong>We can make the variables of the class as read-only or write-only depending on our requirement. If we wish to make the variables as read-only then we have to omit the setter methods like setName(), setAge() etc. from the above program or if we wish to make the variables as write-only then we have to omit the get methods like getName(), getAge() etc. from the above program</li>
<li><strong>Reusability:</strong>Encapsulation also improves the re-usability and easy to change with new requirements.</li>
<li><strong>Testing code is easy:</strong>Encapsulated code is easy to test for unit testing.</li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>&nbsp;</strong></p>
<h1>Abstraction in Java</h1>
<p><a href="https://www.geeksforgeeks.org/abstraction-in-java-2/">https://www.geeksforgeeks.org/abstraction-in-java-2/</a></p>
<p><strong>Abstraction:&nbsp;</strong>Hiding the internal implementation of the feature and only showing the functionality to the users. i.e. what it works (showing), how it works (hiding). Both&nbsp;<a href="https://www.geeksforgeeks.org/abstract-classes-in-java/">abstract class</a>&nbsp;and&nbsp;<a href="http://quiz.geeksforgeeks.org/interfaces-in-java/">interface</a>&nbsp;are used for abstraction.</p>
<p>Data Abstraction is the property by virtue of which only the essential details are displayed to the user.The trivial or the non-essentials units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.</p>
<p>Data Abstraction may also be defined as the process of identifying only the required characteristics of an object ignoring the irrelevant details.The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the objects.</p>
<p>Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of car or applying brakes will stop the car but he does not know about how on pressing the accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is.</p>
<p><strong>Abstract classes and Abstract methods :</strong></p>
<ol>
<li>An abstract class is a class that is declared with&nbsp;<a href="https://www.geeksforgeeks.org/abstract-keyword-in-java/">abstract keyword.</a></li>
<li>An abstract method is a method that is declared without an implementation.</li>
<li>An abstract class may or may not have all abstract methods. Some of them can be concrete methods</li>
<li>A method defined abstract must always be redefined in the subclass,thus making&nbsp;<a href="http://contribute.geeksforgeeks.org/overriding-in-java/">overriding</a>compulsory OR either make subclass itself abstract.</li>
<li>Any class that contains one or more abstract methods must also be declared with abstract keyword.</li>
<li>There can be no object of an abstract class.That is, an abstract class can not be directly instantiated with the&nbsp;<a href="https://www.geeksforgeeks.org/new-operator-java/"><em>new operator</em></a>.</li>
<li>An abstract class can have parametrized constructors and default constructor is always present in an abstract class.</li>
</ol>
<p>&nbsp;</p>
<p><strong>What are the differences between Abstraction and Encapsulation?</strong></p>
<p>Abstraction and encapsulation are complementary concepts. On the one hand, abstraction focuses on the behavior of an object. On the other hand, encapsulation focuses on the implementation of an object&rsquo;s behavior. Encapsulation is usually achieved by hiding information about the internal state of an object and thus, can be seen as a strategy used in order to provide abstraction.</p>
<p>&nbsp;</p>
<h1>Interface in Java</h1>
<p><a href="https://www.geeksforgeeks.org/inheritance-in-java/">https://www.geeksforgeeks.org/inheritance-in-java/</a></p>
<p>Like a class, an interface can have methods and variables, but the methods declared in an interface are by default abstract (only method signature, no body). &nbsp;</p>
<ul>
<li>Interfaces specify what a class must do and not how. It is the blueprint of the class.</li>
<li>An Interface is about capabilities like a Player may be an interface and any class implementing Player must be able to (or must implement) move(). So it specifies a set of methods that the class has to implement.</li>
<li>If a class implements an interface and does not provide method bodies for all functions specified in the interface, then the class must be declared abstract.</li>
</ul>
<p><strong>Why do we use interface ?</strong></p>
<ul>
<li>It is used to achieve total abstraction.</li>
<li>Since java does not support multiple inheritance in case of class, but by using interface it can achieve multiple inheritance .</li>
<li>It is also used to achieve loose coupling.</li>
<li>Interfaces are used to implement abstraction. So the question arises why use interfaces when we have abstract classes?</li>
</ul>
<p>The reason is, abstract classes may contain non-final variables, whereas variables in interface are final, public and static.</p>
<p>&nbsp;</p>
<table width="686">
<tbody>
<tr>
<td width="686">
<p>// A simple interface</p>
<p>interface Player</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;final int id = 10;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;int move();</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<ul>
<li>To declare an interface, use&nbsp;<strong>interface</strong> It is used to provide total abstraction. That means all the methods in an interface are declared with an empty body and are public and all fields are public, static and final by default. A class that implements an interface must implement all the methods declared in the interface. To implement interface use&nbsp;<strong>implements</strong>keyword.</li>
</ul>
<p>&nbsp;</p>
<p><strong>Marker interface in Java</strong></p>
<p><a href="https://www.geeksforgeeks.org/marker-interface-java/">https://www.geeksforgeeks.org/marker-interface-java/</a></p>
<p>It is an empty interface (no field or methods). Examples of marker interface are Serializable, Clonnable and Remote interface. All these interfaces are empty interfaces.</p>
<p>&nbsp;</p>
<h1>Packages In Java</h1>
<p><a href="https://www.geeksforgeeks.org/packages-in-java/">https://www.geeksforgeeks.org/packages-in-java/</a></p>
<p><strong>&nbsp;</strong></p>
<p><strong>Package</strong>&nbsp;in&nbsp;<a href="https://www.geeksforgeeks.org/java/">Java</a>&nbsp;is a mechanism to encapsulate a group of classes, sub packages and interfaces. Packages are used for:</p>
<ul>
<li>Preventing naming conflicts. For example there can be two classes with name Employee in two packages, college.staff.cse.Employee and college.staff.ee.Employee</li>
<li>Making searching/locating and usage of classes, interfaces, enumerations and annotations easier</li>
<li>Providing controlled access: protected and default have package level access control. A protected member is accessible by classes in the same package and its subclasses. A default member (without any access specifier) is accessible by classes in the same package only.</li>
<li>Packages can be considered as data encapsulation (or data-hiding).</li>
</ul>
<p>&nbsp;</p>
<h1>Classes and Objects in Java</h1>
<p><a href="https://www.geeksforgeeks.org/classes-objects-java/">https://www.geeksforgeeks.org/classes-objects-java/</a></p>
<p>Classes and Objects are basic concepts of Object Oriented Programming which revolve around the real life entities.</p>
<p><strong>Class</strong></p>
<p>A class is a user defined blueprint or prototype from which objects are created. &nbsp;It represents the set of properties or methods that are common to all objects of one type. In general, class declarations can include these components, in order:</p>
<ol>
<li><strong>Modifiers</strong>: A class can be public or has default access (Refer&nbsp;<a href="https://www.geeksforgeeks.org/access-specifiers-for-classes-or-interfaces-in-java/">this</a>&nbsp;for details).</li>
<li><strong>Class name:</strong>The name should begin with a initial letter (capitalized by convention).</li>
<li><strong>Superclass(if any):</strong>The name of the class&rsquo;s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.</li>
<li><strong>Interfaces(if any):</strong>A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.</li>
<li><strong>Body:</strong>The class body&nbsp;surrounded by braces, { }.</li>
</ol>
<p>Constructors are used for initializing new objects. Fields are variables that provides the state of the class and its objects, and methods are used to implement the behavior of the class and its objects.</p>
<p>There are various types of classes that are used in real time applications such as&nbsp;<a href="https://www.geeksforgeeks.org/inner-class-java/">nested classes</a>,&nbsp;<a href="https://www.geeksforgeeks.org/anonymous-inner-class-java/">anonymous classes</a>,&nbsp;<a href="https://www.geeksforgeeks.org/lambda-expressions-java-8/">lambda expressions</a>.</p>
<p>&nbsp;</p>
<p><strong>Object</strong></p>
<p>It is a basic unit of Object Oriented Programming&nbsp;and represents the real life entities. &nbsp;A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of :</p>
<ol>
<li><strong>State&nbsp;</strong>: It is represented by attributes of an object. It also reflects the properties of an object.</li>
<li><strong>Behavior&nbsp;</strong>: It is represented by methods of an object. It also reflects the response of an object with other objects.</li>
<li><strong>Identity&nbsp;</strong>: It gives a unique name to an object and enables one object to interact with other objects.</li>
</ol>
<p>&nbsp;</p>
<p><strong>Ways to create object of a class</strong></p>
<p>There are four ways to create objects in java.Strictly speaking there is only one way(by using&nbsp;<em>new</em>&nbsp;keyword),and the rest internally use&nbsp;<em>new</em>&nbsp;keyword.</p>
<p><strong>&nbsp;</strong></p>
<p><strong>Using new keyword&nbsp;</strong>: It is the most common and general way to create object in java.&nbsp;Example:</p>
<p>Test t = new Test();</p>
<p><strong>&nbsp;</strong></p>
<p><strong>Using Class.forName(String className) method&nbsp;</strong>: There is a pre-defined class in java.lang package with name Class. The forName(String className) method returns the Class object associated with the class with the given string name.We have to give the fully qualified name for a class. On calling new Instance() method on this Class object returns new instance of the class with the given string name.</p>
<p>Test obj = (Test)Class.forName("com.p1.Test").newInstance();</p>
<p><strong>&nbsp;</strong></p>
<p><strong>Using clone() method</strong>: clone() method is present in Object class. It creates and returns a copy of the object.</p>
<p>t1 = new Test();</p>
<p>Test t2 = (Test)t1.clone();</p>
<p><strong>&nbsp;</strong></p>
<p><strong>Deserialization&nbsp;</strong>: De-serialization is technique of reading an object from the saved state in a file. Refer&nbsp;<a href="http://quiz.geeksforgeeks.org/serialization-in-java/">Serialization/De-Serialization in java</a></p>
<p>FileInputStream file = new FileInputStream(filename);</p>
<p>ObjectInputStream in = new ObjectInputStream(file);</p>
<p>Object obj = in.readObject()</p>
<p>&nbsp;</p>
<h1>Methods in Java</h1>
<p><a href="https://www.geeksforgeeks.org/methods-in-java/">https://www.geeksforgeeks.org/methods-in-java/</a></p>
<p>&nbsp;</p>
<p>A method is a collection of statements that perform some specific task and return the result to the caller. A method can perform some specific task without returning anything. Methods allow us to&nbsp;<strong>reuse</strong>&nbsp;the code without retyping the code.&nbsp;</p>
<p>&nbsp;</p>
<p><strong>Method Declaration</strong></p>
<p>In general, method declarations has six components :</p>
<ul>
<li><strong>Modifier</strong>-: Defines&nbsp;<strong>access type</strong>of the method i.e. from where it can be accessed in your application. In Java, there 4 type of the access specifiers.
<ul>
<li>public: accessible in all class in your application.</li>
<li>protected: accessible within the class in which it is defined and in its&nbsp;<strong>subclass(es)</strong></li>
<li>private: accessible only within the class in which it is defined.</li>
<li>default (declared/defined without using any modifier) : accessible within same class and package within which its class is defined.</li>
</ul>
</li>
<li><strong>The return type</strong>: The data type of the value returned by the method or void if does not return a value.</li>
<li><strong>Method Name</strong>: the rules for field names apply to method names as well, but the convention is a little different.</li>
<li><strong>Parameter list&nbsp;</strong>: Comma separated list of the input parameters are defined, preceded with their data type, within the enclosed parenthesis. If there are no parameters, you must use empty parentheses ().</li>
<li><strong>Exception list&nbsp;</strong>: The exceptions you expect by the method can throw, you can specify these exception(s).</li>
<li><strong>Method body&nbsp;</strong>: it is enclosed between braces. The code you need to be executed to perform your intended operations.</li>
</ul>
<p><strong>Memory allocation for methods calls</strong></p>
<p>Methods calls are implemented through stack. Whenever a method is called a stack frame is created within the stack area and after that the arguments passed to and the local variables and value to be returned by this called method are stored in this stack frame and when execution of the called method is finished, the allocated stack frame would be deleted. There is a stack pointer register that tracks the top of the stack&nbsp;which is adjusted accordingly.</p>
<h1>Constructors in Java</h1>
<p><a href="https://www.geeksforgeeks.org/constructors-in-java/">https://www.geeksforgeeks.org/constructors-in-java/</a></p>
<p>&nbsp;</p>
<p>Constructors are used to initialize the object&rsquo;s state. Like&nbsp;<a href="https://www.geeksforgeeks.org/methods-in-java/">methods</a>, a constructor also contains&nbsp;<strong>collection of statements(i.e. instructions)</strong>&nbsp;that are executed at time of Object creation.</p>
<p><strong>Need of Constructor</strong><br /> Think of a Box. If we talk about a box class then it will have some class variables (say length, breadth, and height). But when it comes to creating its object(i.e Box will now exist in computer&rsquo;s memory), then can a box be there with no value defined for its dimensions. The answer is no.<br /> So constructors are used to assign values to the class variables at the time of object creation, either explicitly done by the programmer or by Java itself (default constructor).</p>
<p><strong>When is a Constructor called ?</strong><br /> Each time an object is created using&nbsp;<strong>new()</strong>&nbsp;keyword at least one constructor (it could be default constructor) is invoked to assign initial values to the&nbsp;<strong>data members&nbsp;</strong>of the same class.</p>
<p>A constructor is invoked at the time of object or instance creation. For Example:</p>
<p>class Geek{&nbsp;&nbsp; &nbsp;&nbsp;.......&nbsp; // A Constructor&nbsp; new Geek() {}&nbsp; .......}// We can create an object of the above class// using the below statement. This statement// calls above constructor.Geek obj = new Geek();</p>
<p><strong>Rules for writing Constructor:</strong></p>
<ul>
<li>Constructor(s) of a class must has same name as the class name in which it resides.</li>
<li>A constructor in Java can not be abstract, final, static and Synchronized.</li>
<li>Access modifiers can be used in constructor declaration to control its access i.e which other class can call the constructor.</li>
</ul>
<p><strong>Types of constructor</strong></p>
<p>There are two type of constructor in Java:</p>
<ol>
<li><strong>No-argument constructor:&nbsp;</strong>A constructor that has no parameter is known as default constructor. If we don&rsquo;t define a constructor in a class, then compiler creates&nbsp;<strong>default constructor(with no arguments)</strong>for the class. And if we write a constructor with arguments or no-arguments then the compiler does not create a default constructor.<br /> Default constructor provides the default values to the object like 0, null, etc. depending on the type.</li>
<li><strong>Parameterized Constructor:&nbsp;</strong>A constructor that has parameters is known as parameterized constructor. If we want to initialize fields of the class with your own values, then use a parameterized constructor.</li>
</ol>
<p>&nbsp;</p>
<p><strong>Does constructor return any value?</strong></p>
<p>There are no &ldquo;return value&rdquo; statements in constructor, but constructor returns current class instance. We can write &lsquo;return&rsquo; inside a constructor.</p>
<p><strong>Constructor Overloading</strong></p>
<p>Like methods, we can overload constructors for creating objects in different ways. Compiler differentiates constructors on the basis of numbers of parameters, types of the parameters and order of the parameters.</p>
<p><strong>How constructors are different from methods in Java?</strong></p>
<ul>
<li>Constructor(s) must have the same name as the class within which it defined while it is not necessary for the method in java.</li>
<li>Constructor(s) do not return any type while method(s) have the return type or&nbsp;<strong>void</strong>if does not return any value.</li>
<li>Constructor is called only once at the time of Object creation while method(s) can be called any numbers of time.</li>
</ul>
<p>&nbsp;</p>
<p><strong>Why Constructors are not inherited in Java?</strong></p>
<p><strong>&nbsp;</strong></p>
<p>Constructor is a block of code that allows you to create an object of class and has same name as class with no explicit return type.</p>
<p>Whenever a class (child class) extends another class (parent class), the sub class inherits state and behavior in the form of variables and methods from its super class but it does not inherit constructor of super class because of following reasons:</p>
<ul>
<li>Constructors are special and have same name as class name. So if constructors were inherited in child class then child class would contain a parent class constructor which is against the constraint that constructor should have same name as class name.</li>
<li>Now suppose if constructors can be inherited then it will be impossible to achieving encapsulation. Because by using a super class&rsquo;s constructor we can access/initialize private members of a class.</li>
<li>A constructor cannot be called as a method. It is called when object of the class is created so it does not make sense of creating child class object using parent class constructor notation. i.e. Child c = new Parent();</li>
<li>A parent class constructor is not inherited in child class and this is why super() is added automatically in child class constructor if there is no explicit call to super or this.</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>Constructors Interview Questions</h1>
<p><a href="https://www.geeksforgeeks.org/java-interview-questions-constructors/">https://www.geeksforgeeks.org/java-interview-questions-constructors/</a></p>
<p><strong>&nbsp;</strong></p>
<ol>
<li><strong>What is a&nbsp;</strong><a href="https://www.geeksforgeeks.org/constructors-in-java/"><strong>Constructor?</strong></a><br /> Constructors are used to initialize the object&rsquo;s state. Like methods, a constructor also contains collection of statements(i.e. instructions) that are executed at time of Object creation.</li>
</ol>
<p>&nbsp;</p>
<ol start="2">
<li><strong>Do we have&nbsp;</strong><a href="https://www.geeksforgeeks.org/copy-constructor-in-java/"><strong>Copy Constructor in Java</strong></a><strong>?</strong><br /> Like C++, Java also supports copy constructor. But, unlike C++, Java&nbsp;<strong>doesn&rsquo;t create a default copy constructor</strong>if you don&rsquo;t write your own.<br /> To copy the values of one object into another in java, you can use:
<ul>
<li>Constructor</li>
<li>Assigning the values of one object into another</li>
<li><a href="https://www.geeksforgeeks.org/clone-method-in-java-2/">clone() method</a>of Object class</li>
</ul>
</li>
</ol>
<p>&nbsp;</p>
<ol start="3">
<li><strong>What is&nbsp;</strong><a href="https://www.geeksforgeeks.org/constructor-chaining-java-examples/"><strong>Constructor Chaining</strong></a><strong>?</strong><br /> Constructor Chaining is a technique of calling another constructor from one constructor. this() is used to call same class constructor where as super() is used to call super class constructor.</li>
</ol>
<p><strong>&nbsp;</strong></p>
<p>// Java program to illustrate Constructor Chaining</p>
<p>// within same class Using this() keyword</p>
<p>class Temp</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// default constructor 1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// default constructor will call another constructor</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// using this keyword from same class</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Temp()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls constructor 2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(5);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("The Default constructor");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// parameterized constructor 2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Temp(int x)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls constructor 3</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(5, 15);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// parameterized constructor 3</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Temp(int x, int y)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(x * y);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// invokes default constructor first</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Temp();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<ol start="4">
<li><strong>Can we call sub class constructor from super class constructor?</strong><br /> There is no way in java to call sub class constructor from a super class constructor.</li>
</ol>
<p>&nbsp;</p>
<ol start="5">
<li><strong>What happens if you keep a return type for a constructor?</strong><br /> Ideally, Constructor must not have a return type. By definition, if a method has a return type, it&rsquo;s not a constructor.(<a href="http://docs.oracle.com/javase/specs/#8.8">8 Declaration</a>) It will be treated as a normal method. But compiler gives a warning saying that method has a constructor name.Example:</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class GfG {&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int GfG() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp; // Warning for the return type&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<ol start="6">
<li><strong>What is No-arg constructor?</strong><br /> Constructor without arguments is called no-arg constructor. Default constructor in java is always a no-arg constructor.</li>
</ol>
<p>&nbsp; class GfG {</p>
<p>&nbsp;&nbsp;&nbsp; public GfG() {&nbsp; //No-arg constructor &nbsp;}</p>
<p>&nbsp; }</p>
<ol start="7">
<li><strong>How a no &ndash; argument constructor is different from&nbsp;</strong><a href="https://www.geeksforgeeks.org/g-fact-50/"><strong>default Constructor</strong></a><strong>?</strong><br /> If a class contains no constructor declarations, then a default constructor with no formal parameters and no throws clause is implicitly declared.</li>
</ol>
<p>If the class being declared is the primordial class Object, then the default constructor has an empty body. Otherwise, the default constructor simply invokes the superclass constructor with no arguments.</p>
<ol start="8">
<li><strong>What are&nbsp;</strong><a href="https://www.geeksforgeeks.org/private-constructors-and-singleton-classes-in-java/"><strong>private constructors</strong></a><strong>and where are they used?</strong><br /> Like any method we can provide access specifier to the constructor. If it&rsquo;s made private, then it can only be accessed inside the class.<br /> The major scenarios where we use private constructor:
<ul>
<li>Internal Constructor chaining</li>
<li>Singleton class design pattern</li>
</ul>
</li>
</ol>
<p>&nbsp;</p>
<ol start="9">
<li><strong>When do we need&nbsp;</strong><a href="https://www.geeksforgeeks.org/constructor-overloading-java/"><strong>Constructor Overloading</strong></a><strong>?</strong><br /> Sometimes there is a need of initializing an object in different ways. This can be done using constructor overloading. Different constructors can do different work by implementing different line of codes and are called based on the type and no of parameters passed.<br /> According to the situation , a constructor is called with specific number of parameters among overloaded constructors.</li>
</ol>
<p>&nbsp;</p>
<ol start="10">
<li><strong>Do we have destructors in Java?</strong><br /> No, Because Java is a garbage collected language you cannot predict when (or even if) an object will be destroyed. Hence there is no direct equivalent of a destructor.</li>
</ol>
<p>&nbsp;</p>
<p><strong>&nbsp;</strong></p>
<p><strong>&nbsp;</strong></p>
<h1>static keyword in java</h1>
<p><a href="https://www.geeksforgeeks.org/static-keyword-java/">https://www.geeksforgeeks.org/static-keyword-java/</a></p>
<p><em>&nbsp;</em></p>
<p><em>static</em>&nbsp;is a non-access modifier in Java which is applicable for the following:</p>
<ol>
<li>blocks</li>
<li>variables</li>
<li>methods</li>
<li>nested classes</li>
</ol>
<p>To create a static member(block,variable,method,nested class), precede its declaration with the keyword&nbsp;<em>static</em>. When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object. For example, in below java program, we are accessing static method&nbsp;<em>m1()</em>&nbsp;without creating any object of&nbsp;<em>Test</em>&nbsp;class.</p>
<p><strong>Static blocks</strong></p>
<p>If you need to do computation in order to initialize your&nbsp;<strong>static variables</strong>, you can declare a static block that gets executed exactly once, when the class is first loaded. Consider the following java program demonstrating use of static blocks.</p>
<p>// Java program to demonstrate use of static blocks</p>
<p>class Test</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int a = 10;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int b;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static block</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Static block initialized.");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = a * 4;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("from main");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Value of a : "+a);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Value of b : "+b);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>Output:</p>
<p>Static block initialized.from mainValue of a : 10Value of b : 40</p>
<p>For Detailed article on static blocks, see&nbsp;<a href="https://www.geeksforgeeks.org/g-fact-79/">static blocks</a></p>
<p><strong>Static variables</strong></p>
<p>When a variable is declared as static, then a single copy of variable is created and shared among all objects at class level. Static variables are, essentially, global variables. All instances of the class share the same static variable.</p>
<p><strong>Important points for static variables :-</strong></p>
<ul>
<li>We can create static variables at class-level only. See&nbsp;<a href="https://www.geeksforgeeks.org/g-fact-47/">here</a></li>
<li>static block and static variables are executed in order they are present in a program.</li>
</ul>
<p>Below is the java program to demonstrate that static block and static variables are executed in order they are present in a program.</p>
<table width="722">
<tbody>
<tr>
<td width="722">
<p>// java program to demonstrate execution</p>
<p>// of static blocks and variables</p>
<p>class Test</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int a = m1();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static block</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Inside static block");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int m1() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("from m1");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 20;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static method(main !!)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Value of a : "+a);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("from main");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>Output:</p>
<p>from m1</p>
<p>Inside static block</p>
<p>Value of a : 20</p>
<p>from main</p>
<p><strong>Static methods</strong></p>
<p>When a method is declared with&nbsp;<em>static</em>&nbsp;keyword, it is known as static method. The most common example of a static method is&nbsp;<em>main( )</em>&nbsp;method.As discussed above, Any static member can be accessed before any objects of its class are created, and without reference to any object.Methods declared as static have several restrictions:</p>
<ul>
<li>They can only directly call other static methods.</li>
<li>They can only directly access static data.</li>
<li>They cannot refer to&nbsp;<a href="https://www.geeksforgeeks.org/this-reference-in-java/">this</a>or&nbsp;<a href="https://www.geeksforgeeks.org/super-keyword/">super</a>&nbsp;in any way.</li>
</ul>
<p>Below is the java program to demonstrate restrictions on static methods.</p>
<table width="722">
<tbody>
<tr>
<td width="722">
<p>// java program to demonstrate restriction on static methods</p>
<p>class Test</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int a = 10;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// instance variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;int b = 20;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static void m1()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = 20;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("from m1");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Cannot make a static reference to the non-static field b</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = 10; // compilation error</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Cannot make a static reference to the&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// non-static method m2() from the type Test</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m2();&nbsp; // compilation error</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp; Cannot use super in a static context</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(super.a); // compiler error&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// instance method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;void m2()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("from m2");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// main method&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p><strong>When to use static variables and methods?</strong></p>
<p>Use the static variable for the property that is common to all objects. For example, in class Student, all students shares the same college name. Use static methods for changing static variables.</p>
<p>Consider the following java program, that illustrate the use of&nbsp;<em>static</em>&nbsp;keyword with variables and methods.</p>
<table width="722">
<tbody>
<tr>
<td width="722">
<p>// A java program to demonstrate use of</p>
<p>// static keyword with methods and variables</p>
<p>&nbsp;&nbsp;</p>
<p>// Student class</p>
<p>class Student&nbsp;</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;String name;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;int rollNo;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static String cllgName;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static counter to set unique roll no</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int counter = 0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public Student(String name)&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.rollNo = setRollNo();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// getting unique rollNo</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// through static variable(counter)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int setRollNo()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return counter;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// static method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static void setCllg(String name){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cllgName = name ;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;// instance method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;void getStudentInfo(){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("name : " + this.name);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("rollNo : " + this.rollNo);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// accessing static variable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("cllgName : " + cllgName);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;&nbsp;</p>
<p>//Driver class</p>
<p>public class StaticDemo&nbsp;</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calling static method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// without instantiating Student class</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student.setCllg("XYZ");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student s1 = new Student("Alice");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student s2 = new Student("Bob");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1.getStudentInfo();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2.getStudentInfo();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>Output:</p>
<p>name : Alice</p>
<p>rollNo : 1</p>
<p>cllgName : XYZ</p>
<p>name : Bob</p>
<p>rollNo : 2</p>
<p>cllgName : XYZ</p>
<p><strong>Static nested classes</strong><strong> :&nbsp;</strong>We can not declare top-level class with a static modifier, but can declare&nbsp;<a href="https://www.geeksforgeeks.org/nested-classes-java/">nested classes</a>&nbsp;as static. Such type of classes are called Nested static classes. For static nested class, see&nbsp;<a href="https://www.geeksforgeeks.org/static-class-in-java/">static nested class in java</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>Java Interview Questions 1</h1>
<p><strong>&nbsp;</strong></p>
<p><a href="https://www.geeksforgeeks.org/commonly-asked-java-programming-interview-questions-set-1/?ref=rp">https://www.geeksforgeeks.org/commonly-asked-java-programming-interview-questions-set-1/?ref=rp</a></p>
<p><strong>Explain Final keyword in java?</strong></p>
<p>Final keyword in java is used to restrict usage of variable, class and method.<br /> <br /> Variable: Value of Final variable is constant, you can not change it.<br /> Method: you can&rsquo;t override a Final method.<br /> Class: you can&rsquo;t inherit from Final class.</p>
<p><strong>When is the super keyword used?</strong><br /> super keyword is used to refer:</p>
<ul>
<li>immediate parent class constructor,</li>
<li>immediate parent class variable,</li>
<li>immediate parent class method.</li>
</ul>
<p>&nbsp;</p>
<p><strong>What is the difference between StringBuffer and String?</strong><br /> &nbsp;</p>
<p>String is an Immutable class, i.e. you can not modify its content once created. While StringBuffer is a mutable class, means you can change its content later. Whenever we alter content of String object, it creates a new string and refer to that,it does not modify the existing one. This is the reason that the performance with StringBuffer is better than with String.<br /> Refer&nbsp;<a href="https://www.geeksforgeeks.org/g-fact-27-string-vs-stringbuilder-vs-stringbuffer/">this</a>&nbsp;for details.</p>
<p>&nbsp;<br /> <strong>Why multiple inheritance is not supported in java?</strong><br /> &nbsp;</p>
<p>Java supports multiple inheritance but not through classes, it supports only through its interfaces. The reason for not supporting multiple inheritance is to avoid the conflict and complexity arises due to it and keep Java a Simple Object Oriented Language. If we recall&nbsp;<a href="https://www.geeksforgeeks.org/multiple-inheritance-in-c/">this in C++</a>, there is a special case of multiple inheritance (diamond problem) where you have a multiple inheritance with two classes which have methods in conflicts. So, Java developers decided to avoid such conflicts and didn&rsquo;t allow multiple inheritance through classes at all.</p>
<p>&nbsp;<br /> <strong>Can a top level class be private or protected?</strong><br /> &nbsp;</p>
<p>Top level classes in java can&rsquo;t be private or protected, but inner classes in java can. The reason for not making a top level class as private is very obvious, because nobody can see a private class and thus they can not use it. Declaring a class as protected also doesn&rsquo;t make any sense. The only difference between default visibility and protected visibility is that we can use it in any package by inheriting it. Since in java there is no such concept of package inheritance, defining a class as protected is no different from default.</p>
<p>&nbsp;<br /> <strong>What is the difference between &lsquo;throw&rsquo; and &lsquo;throws&rsquo; in Java Exception Handling?</strong><br /> &nbsp;</p>
<p>Following are the differences between two:</p>
<ul>
<li>throw keyword is used to throw Exception from any method or static block whereas throws is used to indicate that which Exception can possibly be thrown by this method</li>
<li>If any method throws checked Exception, then caller can either handle this exception(using try catch block )or can re throw it by declaring another &lsquo;throws&rsquo; clause in method declaration.</li>
<li>throw clause can be used in any part of code where you feel a specific exception needs to be thrown to the calling method</li>
</ul>
<p>E.g.<br /> <strong>throw</strong><br /> throw new Exception(&ldquo;You have some exception&rdquo;)<br /> throw new IOException(&ldquo;Connection failed!!&rdquo;)<br /> <strong>throws</strong><br /> throws IOException, NullPointerException, ArithmeticException</p>
<p>&nbsp;</p>
<p><strong>What is finalize() method?</strong><br /> &nbsp;<br /> Unlike c++ , we don&rsquo;t need to destroy objects explicitly in Java. &lsquo;<a href="https://www.geeksforgeeks.org/garbage-collection-java/">Garbage Collector</a>&lsquo; does that automatically for us. Garbage Collector checks if no references to an object exist, that object is assumed to be no longer required, and the memory occupied by the object can be freed. Sometimes an object can hold non-java resources such as file handle or database connection, then you want to make sure these resources are also released before object is destroyed. To perform such operation Java provide protected void finalize() in object class. You can override this method in your class and do the required tasks. Right before an object is freed, the java run time calls the finalize() method on that object. Refer&nbsp;<a href="https://www.geeksforgeeks.org/garbage-collection-java/">this</a>&nbsp;for more details.</p>
<p>&nbsp;<br /> <strong>Difference in Set and List interface?</strong><br /> &nbsp;</p>
<p>Set and List both are child interface of Collection interface. There are following two main differences between them</p>
<ul>
<li>List can hold duplicate values but Set doesn&rsquo;t allow this.</li>
<li>In List interface data is present in the order you inserted but in the case of Set insertion order is not preserved.</li>
</ul>
<p>&nbsp;<br /> <strong>What will happen if you put System.exit(0) on try or catch block? Will finally block execute?</strong><br /> &nbsp;<br /> By Calling System.exit(0) in try or catch block, we can skip the finally block. System.exit(int) method can throw a SecurityException. If Sysytem.exit(0) exits the JVM without throwing that exception then finally block will not execute. But, if System.exit(0) does throw security exception then finally block will be executed.</p>
<p>&nbsp;</p>
<h1>Java Interview Questions 2</h1>
<p><a href="https://www.geeksforgeeks.org/commonly-asked-java-programming-interview-questions-set-2/?ref=rp">https://www.geeksforgeeks.org/commonly-asked-java-programming-interview-questions-set-2/?ref=rp</a></p>
<p><strong>Q1. Can we&nbsp;</strong><strong><a href="https://www.geeksforgeeks.org/can-we-overload-or-override-static-methods-in-java/">Overload or Override static methods in java</a>?</strong></p>
<ul>
<li><strong>Overriding :</strong>Overriding is related to run-time polymorphism. A subclass (or derived class) provides a specific implementation of a method in superclass (or base class) at runtime.</li>
<li><strong>Overloading:</strong>Overloading is related to compile time (or static) polymorphism. This feature allows different methods to have same name, but different signatures, especially number of input parameters and type of input paramaters.</li>
<li><strong>Can we overload static methods? &nbsp;&nbsp;</strong>The answer is&nbsp;<strong>&lsquo;Yes&rsquo;</strong>. We can have two ore more static methods with same name, but differences in input parameters</li>
<li><strong>Can we Override static methods in java? &nbsp;</strong>We can declare static methods with same signature in subclass, but it is not considered overriding as there won&rsquo;t be any run-time polymorphism. Hence the answer is&nbsp;<strong>&lsquo;No&rsquo;</strong>.&nbsp;Static methods cannot be overridden because method overriding only occurs in the context of dynamic (i.e. runtime) lookup of methods. Static methods (by their name) are looked up statically (i.e. at compile-time).</li>
</ul>
<p>Read&nbsp;<a href="https://www.geeksforgeeks.org/can-we-overload-or-override-static-methods-in-java/">more</a></p>
<p>&nbsp;</p>
<p><strong>Q2. Why the main method is static in java?</strong><br /> The method is static because otherwise there would be ambiguity: which constructor should be called? Especially if your class looks like this:</p>
<p>public class JavaClass</p>
<p>{</p>
<p>&nbsp; protected JavaClass(int x)</p>
<p>&nbsp; {&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp; public void main(String[] args)</p>
<p>&nbsp;&nbsp; {</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>Should the JVM call new JavaClass(int)? What should it pass for x? If not, should the JVM instantiate JavaClass without running any constructor method? because that will special-case your entire class &ndash; sometimes you have an instance that hasn&rsquo;t been initialized, and you have to check for it in every method that could be called. There are just too many edge-cases and ambiguities for it to make sense for the JVM to have to instantiate a class before the entry point is called. That&rsquo;s why main is static.</p>
<p>&nbsp;</p>
<p><strong>Q3. What happens if you remove static modifier from the main method?</strong><br /> Program compiles successfully. But at runtime throws an error &ldquo;NoSuchMethodError&rdquo;.</p>
<p>&nbsp;</p>
<p><strong>Q4. What is the&nbsp;</strong><strong><a href="https://www.geeksforgeeks.org/variable-scope-in-java/">scope of variables</a>&nbsp;in Java in following cases?&nbsp;</strong></p>
<ul>
<li><strong>Member Variables</strong>(Class Level Scope) :&nbsp;The&nbsp;member&nbsp;variables must be declared inside class (outside any function). They can be directly accessed anywhere in class</li>
<li><strong>Local Variables&nbsp;</strong>(Method Level Scope) :&nbsp;Variables declared inside a method have method level scope and can&rsquo;t be accessed outside the method.</li>
<li><strong>Loop Variables&nbsp;</strong>(Block Scope) :&nbsp;A variable declared inside pair of brackets &ldquo;{&rdquo; and &ldquo;}&rdquo; in a method has scope withing the brackets only.</li>
</ul>
<p>Read&nbsp;<a href="https://www.geeksforgeeks.org/variable-scope-in-java/">more</a></p>
<p>&nbsp;</p>
<p><strong>Q5. What is</strong><strong><a href="http://quiz.geeksforgeeks.org/this-reference-in-java/">&nbsp;&ldquo;this&rdquo; keyword in java</a>?</strong><br /> Within an instance method or a constructor, this is a reference to the current object &mdash; the object whose method or constructor is being called. You can refer to any member of the current object from within an instance method or a constructor by using this.<br /> Usage of this keyword</p>
<ul>
<li>Used to refer current class instance variable.</li>
<li>To invoke current class constructor.</li>
<li>It can be passed as an argument in the method call.</li>
<li>It can be passed as argument in the constructor call.</li>
<li>Used to return the current class instance.</li>
<li>Used to invoke current class method (implicitly)</li>
</ul>
<p>&nbsp;</p>
<p><strong>Q14. What is&nbsp;</strong><strong><a href="http://quiz.geeksforgeeks.org/super-keyword/">&ldquo;super&rdquo; keyword in java</a>?</strong><br /> The super keyword in java is a reference variable that is used to refer parent class objects. The keyword &ldquo;super&rdquo; came into the picture with the concept of Inheritance. Whenever you create the instance of a subclass, an instance of parent class is created implicitly i.e. referred by super reference variable.<br /> Various scenarios of using java super Keyword:</p>
<ul>
<li>super is used to refer immediate parent instance variable</li>
<li>super is used to call parent class method</li>
<li>super() is used to call&nbsp;immediate parent constructor</li>
</ul>
<p>&nbsp;</p>
<p><strong>Q6. What is an&nbsp;</strong><strong><a href="https://www.geeksforgeeks.org/abstract-classes-in-java/">abstract class</a>? How abstract classes are similar or different in Java from C++?</strong><br /> Abstract classes are classes that contain one or more abstract methods. An abstract method is a method that is declared but contains no implementation. Abstract classes may not be instantiated, and require subclasses to provide implementations for the abstract methods.</p>
<ul>
<li>Like C++, in Java, an instance of an abstract class cannot be created, we can have references of abstract class type though.</li>
<li>Like C++, an abstract class can contain constructors in Java. And a constructor of abstract class is called when an instance of a inherited class is created</li>
<li>In Java, we can have an abstract class without any abstract method. This allows us to create classes that cannot be instantiated, but can only be inherited.</li>
<li>Abstract classes can also have final methods (methods that cannot be overridden). For example, the following program compiles and runs fine.</li>
</ul>
<p>&nbsp;</p>
<p><strong>Q7. Which class is the superclass for every class?</strong><br /> Object class</p>
<p>&nbsp;</p>
<p><strong>Q8.&nbsp;</strong><strong><a href="https://www.geeksforgeeks.org/gfact-48-overloading-main-in-java/">Can we overload main() method?</a></strong><br /> The main method in Java is no extra-terrestrial method. Apart from the fact that main() is just like any other method &amp; can be overloaded in a similar manner, JVM always looks for the method signature to launch the program.</p>
<ul>
<li>The normal main method acts as an entry point for the JVM to start the execution of program.</li>
<li>We can overload the main method in Java. But the program doesn&rsquo;t execute the overloaded main method when we run your program, we need to call the overloaded main method from the actual main method only.</li>
</ul>
<p>&nbsp;</p>
<p><strong>Q9. What is&nbsp;</strong><strong><a href="http://quiz.geeksforgeeks.org/cloning-in-java/">object cloning</a>?</strong><br /> Object cloning means to create an exact copy of the original object.&nbsp;If a class needs to support cloning, it must implement java.lang.Cloneable interface and override clone() method from Object class. Syntax of the clone() method is :</p>
<p>protected Object clone() throws CloneNotSupportedException</p>
<p>If the object&rsquo;s class doesn&rsquo;t implement Cloneable interface then it throws an exception &lsquo;CloneNotSupportedException&rsquo; .</p>
<p><strong>Q12. Can we override private methods in Java?</strong><br /> No, a private method cannot be overridden since it is not visible from any other class. Read&nbsp;<a href="https://www.geeksforgeeks.org/can-override-private-methods-java/">more</a></p>
<p>&nbsp;</p>
<p><strong>Q13. What is&nbsp;</strong><strong><a href="https://www.geeksforgeeks.org/blank-final-in-java/">blank final variable</a>?</strong><br /> A final variable in Java can be assigned a value only once, we can assign a value either in declaration or later.</p>
<p>&nbsp;&nbsp;&nbsp; final int i = 10;&nbsp;&nbsp;&nbsp; i = 30; // Error because i is final.</p>
<p>A&nbsp;<strong>blank final</strong>&nbsp;variable in Java is a&nbsp;<a href="https://www.geeksforgeeks.org/g-fact-48/">final</a>&nbsp;variable that is not initialized during declaration. Below is a simple example of blank final.</p>
<p>&nbsp;&nbsp;&nbsp; // A simple blank final example &nbsp;&nbsp;&nbsp;&nbsp;final int i;&nbsp;&nbsp;&nbsp; i = 30;</p>
<p><strong>&nbsp;</strong></p>
<p><strong>Q15. What is</strong><strong><a href="https://www.geeksforgeeks.org/static-class-in-java/">&nbsp;static variable in Java</a>?</strong><br /> The static keyword in java is used for memory management mainly. We can apply java static keyword with variables, methods, blocks and nested class. The static keyword belongs to the class than the instance of the class.</p>
<p>The static can be:</p>
<ul>
<li>variable (also known as class variable)</li>
<li>method (also known as class method)</li>
<li>block</li>
<li>nested class</li>
</ul>
<p>&nbsp;</p>
<p><strong>Q16. Differences between&nbsp;</strong><strong><a href="http://quiz.geeksforgeeks.org/differences-between-hashmap-and-hashtable-in-java/">HashMap and HashTable in Java</a>.</strong><br /> 1. HashMap is non synchronized. It is not-thread safe and can&rsquo;t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.<br /> 2. HashMap allows one null key and multiple null values whereas Hashtable doesn&rsquo;t allow any null key or value.<br /> 3. HashMap is generally preferred over HashTable if thread synchronization is not needed</p>
<p>&nbsp;</p>
<p><strong>Q17. How are Java&nbsp;</strong><strong><a href="https://www.geeksforgeeks.org/g-fact-46/">objects stored in memory</a>?</strong><br /> In Java, all objects are dynamically allocated on&nbsp;<strong>Heap</strong>.&nbsp;</p>
<p>In Java, when we only declare a variable of a class type, only a reference is created (memory is not allocated for the object). To allocate memory to an object, we must use new(). So the object is always allocated memory on the heap</p>
<p>&nbsp;</p>
<p>The static variables are provided the memory in the the same memory segment where the code is stored i.e. Class Area. It is independent of the stack or heap segment of memory. It remains accessible during the complete duration of the program.</p>
<p>&nbsp;</p>
<p>We have 3 segments in our memory:</p>
<ol>
<li>Stack Segment &mdash; contains local variables and Reference variables (variables that hold the address of an object in the heap).</li>
<li>Heap Segment &mdash; contains all created objects in runtime, objects only plus their object attributes (instance variables).</li>
<li>Code Segment &mdash; the segment where the actual compiled Java bytecodes resides when loaded. Static members (variables or methods) are called class members, meaning they reside where the class (bytecode) resides, which is in the Code Segment.</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>Java Interview Questions 3</h1>
<p>&nbsp;</p>
<p><a href="https://www.geeksforgeeks.org/interview-questions-for-java-professionals/?ref=rp">https://www.geeksforgeeks.org/interview-questions-for-java-professionals/?ref=rp</a></p>
<p><strong>&nbsp;</strong></p>
<p><strong>Q1. Explain&nbsp;</strong><a href="https://www.geeksforgeeks.org/differences-jdk-jre-jvm/"><strong>JVM, JRE and JDK</strong></a><strong>?</strong></p>
<p><br /> <strong>JVM (Java Virtual Machine):</strong>&nbsp;JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a Java code. JVM is a part of JRE(Java Runtime Environment).</p>
<p><strong>JRE (Java Runtime Environment):</strong>&nbsp;JRE refers to a runtime environment in which Java&nbsp;bytecode&nbsp;can be executed. It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that JVM uses at runtime. So JRE is&nbsp;a software package that contains what is required to run a Java program. Basically, it&rsquo;s an implementation of the JVM which physically exists.&nbsp;</p>
<p><strong>JDK(Java Development Kit):</strong>&nbsp;It is the tool necessary to compile, document and package Java programs. The JDK completely includes JRE which contains tools for Java programmers. The Java Development Kit is provided free of charge. Along with JRE, it includes an interpreter/loader, a compiler&nbsp;(javac), an archiver (jar), a documentation generator (javadoc) and other tools needed in Java development. In short, it contains JRE + development tools.</p>
<p>&nbsp;</p>
<p><strong>Q2. Explain public static void main(String args[]).</strong></p>
<p><br /> <strong>Public:</strong>&nbsp;Public is an access modifier. Public means that this Method will be accessible by any Class.<br /> <strong>static&nbsp;:</strong>&nbsp;It&nbsp;is a keyword in java which identifies it is class-based i.e it can be accessed without creating the instance of a Class. Since we want the main method to be executed without any instance also, we use static.<br /> <strong>Void:</strong>&nbsp;It is the return type of the method. Void defines the method which will not return any value.<br /> <strong>main:</strong>&nbsp;This is the first method executed by JVM. The signature of the method must be the same.</p>
<p>&nbsp;</p>
<p><strong>In System.out.println(), what is System, out and println?</strong><br /> System is a predefined final class, out is a PrintStream object and println is a built-in overloaded method in the out object.</p>
<p>&nbsp;</p>
<p><strong>Q3. Why Java is platform independent?</strong><br /> Platform independent practically means &ldquo;write once run anywhere&rdquo;. Java is called so because of its&nbsp;<strong>byte codes</strong>&nbsp;which can run on any system irrespective of its underlying operating system.</p>
<p>&nbsp;</p>
<p><strong>Q4. Why is Java not pure Object-oriented?</strong><br /> Java is not considered pure Object-oriented because it supports primitive data-types such as boolean, byte, char, int, float, double, long, short.</p>
<p>&nbsp;</p>
<p><strong>Q5. Define class and object. Explain them with an example using java.</strong></p>
<p><br /> <strong>Class:</strong>&nbsp;A class is a user-defined blueprint or prototype from which objects are created. &nbsp;It represents the set of properties or methods that are common to all objects of one type. In general, class declarations can include these components, in order:</p>
<p><strong>Superclass(if any):</strong>&nbsp;The name of the class&rsquo;s parent (superclass), if any, preceded by the keyword extends. A class can only extend (subclass) one parent.</p>
<p><strong>Interfaces:</strong>&nbsp;A comma-separated list of interfaces implemented by the class, if any, preceded by the keyword implements. A class can implement more than one interface.</p>
<p>&nbsp;</p>
<p><strong>Object:</strong>&nbsp;It is a basic unit of Object Oriented Programming&nbsp;and represents the real-life entities. &nbsp;A typical Java program creates many objects, which as you know, interact by invoking methods. An object consists of :</p>
<p><strong>State&nbsp;:</strong>&nbsp;It is represented by attributes of an object. It also reflects the properties of an object.</p>
<p><strong>Behavior&nbsp;:</strong>&nbsp;It is represented by methods of an object. It also reflects the response of an object with other objects.</p>
<p><strong>Identity&nbsp;:</strong>&nbsp;It gives a unique name to an object and enables one object to interact with other objects.<br /> For Example: Employee is an example of a class<br /> A specific employee with unique identification is an example of an object.</p>
<p>&nbsp;</p>
<p><strong>Q7.Explain the difference between instance variable and a class variable.</strong></p>
<p>&nbsp;</p>
<p>An instance variable is a variable which has one copy per object/instance. That means every object will have one copy of it.<br /> A class variable is a variable which has one copy per class. The class variables will not have a copy in the object.<br /> Example&nbsp;:</p>
<p>class Employee {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;int empNo;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;String empName, department;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;double salary;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static int officePhone;</p>
<p>}</p>
<p>&nbsp;</p>
<p>An object referred by empObj1 is created by using the following:<br /> Employee empObj1 = new Employee();</p>
<p>The objects referred by instance variables empObj1 and empObj2 have separate copies empNo, empName, department, and salary. However, the officePhone belongs to the class(Class Variable) and can be accessed as Employee.officePhone.</p>
<p><strong>Q8. Which class is the superclass of all classes?</strong><br /> <a href="https://www.geeksforgeeks.org/object-class-in-java/">java.lang.Object&nbsp;</a>is the root class for all the java classes and we don&rsquo;t need to extend it.</p>
<p>&nbsp;</p>
<p><strong>Q9.What are constructors in Java?</strong><br /> In Java, constructor refers to a block of code which is used to initialize an object. It must have the same name as that of the class. Also, it has no return type and it is automatically called when an object is created.<br /> If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, also called the default constructor.<br /> This default constructor calls the class parent&rsquo;s no-argument constructor (as it contains only one statement i.e. super();), or the&nbsp;Object&nbsp;class constructor if the class has no other parent (as Object class is a parent of all classes either directly or indirectly).<br /> There are two types of constructors:</p>
<ol>
<li>Default constructor</li>
<li>Parametrized constructor</li>
</ol>
<p>&nbsp;</p>
<p><strong>Q10. What are the different ways to create objects in Java?</strong><br /> There are many different ways to create objects in Java.</p>
<p><a href="https://www.geeksforgeeks.org/different-ways-create-objects-java/">https://www.geeksforgeeks.org/different-ways-create-objects-java/</a></p>
<ul>
<li><strong>Using new Keyword :</strong>Using new keyword is the most basic way to create an object. This is the most common way to create an object in java. Almost 99% of objects are created in this way.</li>
<li><strong>Using&nbsp;</strong><a href="https://www.geeksforgeeks.org/new-operator-vs-newinstance-method-java/"><strong>New Instance&nbsp;</strong></a><strong>:&nbsp;</strong>If we know the name of the class &amp; if it has a public default constructor we can create an object &ndash;<strong>forName</strong>. We can use it to create the Object of a Class. Class.forName actually loads the Class in Java but doesn&rsquo;t create any Object. To Create an Object of the Class you have to use the new Instance Method of the Class.</li>
<li><strong>Using&nbsp;</strong><a href="https://www.geeksforgeeks.org/clone-method-in-java-2/"><strong>clone() method:</strong></a>Whenever clone() is called on any object, the JVM actually creates a new object and copies all content of the previous object into it. Creating an object using the clone method does not invoke any constructor.<br /> To use clone() method on an object we need to implement&nbsp;<strong>Cloneable</strong>&nbsp;and define the clone() method in it&nbsp;&nbsp;&nbsp;</li>
</ul>
<p><strong>Note :</strong></p>
<ul>
<li>Here we are creating the clone of an existing Object and not any new Object.</li>
<li>Class need to implement Cloneable Interface otherwise it will throw&nbsp;<strong>CloneNotSupportedException</strong>.</li>
</ul>
<p><strong>&nbsp;</strong></p>
<ul>
<li><strong>Using&nbsp;</strong><a href="https://www.geeksforgeeks.org/serialization-in-java/"><strong>deserialization&nbsp;</strong></a><strong>:</strong>Whenever we serialize and then deserialize an object, JVM creates a separate object. In&nbsp;<strong>deserialization</strong>, JVM doesn&rsquo;t use any constructor to create the object.<br /> To deserialize an object we need to implement the Serializable interface in the class.</li>
<li><strong>Using newInstance() method of Constructor class :</strong>&nbsp;This is similar to the newInstance() method of a class. There is one newInstance() method in the&nbsp;<strong>lang.reflect.Constructor</strong>&nbsp;class which we can use to create objects. It can also call parameterized constructor, and private constructor by using this newInstance() method.</li>
</ul>
<p>&nbsp;</p>
<p>Both newInstance() methods are known as reflective ways to create objects. In fact newInstance() method of Class internally uses newInstance() method of Constructor class.</p>
<p>&nbsp;</p>
<p><strong>Q11. What&rsquo;s the purpose of Static methods and static variables?</strong></p>
<p><br /> When there is a requirement to share a method or a variable between multiple objects of a class instead of creating separate copies for each object, we use static keyword to make a method or variable shared for all objects.<br /> <strong>Static variable:</strong>&nbsp;Static variables are also known as Class variables.<br /> These variables are declared similarly as instance variables, the difference is that static variables are declared using the static keyword within a class outside any method constructor or block.<br /> Unlike instance variables, we can only have one copy of a static variable per class irrespective of how many objects we create.<br /> Static variables are created at the start of program execution and destroyed automatically when execution ends.<br /> To access static variables, we need not create an object of that class.<br /> Static methods: A static method can be accessed without creating objects. Just by using the Class name the method can be accessed. The static method can only access static variables and not local or global non-static variables.</p>
<p>&nbsp;</p>
<p><strong>Q12. Why static methods cannot access non-static variables or methods?</strong></p>
<p><br /> Ans) A static method cannot access non-static variables or methods because static methods can be accessed without instantiating the class, so if the class is not instantiated the variables are not initialized and thus cannot be accessed from a static method.</p>
<p>&nbsp;</p>
<p><strong>Q13.What is a static class?</strong><br /> A class can be said to be static class if all the variables and methods of the class are static and the constructor is private. Making the constructor private will prevent the class to be instantiated. So the only possibility to access is using the Class name only.</p>
<p>&nbsp;</p>
<p>Q14. How many types of Variable? Explain.<br /> There are three types of variables in Java:</p>
<ol>
<li>Local Variables</li>
<li>Instance Variables</li>
<li>Static Variables</li>
</ol>
<p>&nbsp;</p>
<p>Q15. <strong>What is implicit casting</strong>.</p>
<p>Implicit casting is the process of simply assigning one entity to another without any transformation guidance to the compiler. This type of casting is not permitted in all kinds of transformations and may not work for all scenarios.</p>
<p><strong><u>Example</u></strong></p>
<table width="820">
<tbody>
<tr>
<td>
<p>&nbsp;</p>
</td>
<td width="786">
<p>int i = 1000;</p>
<p>long j = i; //Implicit casting</p>
</td>
</tr>
</tbody>
</table>
<p>Q16. <strong>What is explicit</strong> <strong>casting</strong>.</p>
<p>Explicit casting in the process in which the complier are specifically informed to about transforming the object.</p>
<p><strong><u>Example</u></strong></p>
<table width="787">
<tbody>
<tr>
<td width="1">
<p>&nbsp;</p>
</td>
<td width="786">
<p>long i = 700.20;</p>
<p>int j = (int) i; //Explicit casting</p>
<p>Q16.<strong>What is explicit</strong> <strong>casting</strong>.</p>
<p>Explicit casting in the process in which the complier are specifically informed to about transforming the object.</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><strong>What is the first argument of the String array in main method?</strong></p>
<p>The String array is empty. It does not have any element. If we do not provide any arguments on the command line, then the String array of main method will be empty but not null.</p>
<p>&nbsp;</p>
<p><strong>How can one prove that the array is not null but empty?</strong></p>
<p>Print array.length. It will print 0. That means it is empty. But if it would have been null then it would have thrown a NullPointerException on attempting to print array.length.</p>
<p>&nbsp;</p>
<p><strong>When is static variable loaded? Is it at compile time or runtime? When exactly a static block is loaded in Java?</strong></p>
<p>Static variable are loaded when classloader brings the class to the JVM. It is not necessary that an object has to be created. Static variables will be allocated memory space when they have been loaded. The code in a static block is loaded/executed only once i.e. when the class is first initialized. A class can have any number of static blocks. Static block is not member of a class, they do not have a return statement and they cannot be called directly. Cannot contain this or super. They are primarily used to initialize static fields.</p>
<p>&nbsp;</p>
<p><strong>Explain working of Java Virtual Machine (JVM)?</strong></p>
<p>JVM is an abstract computing machine like any other real computing machine which first converts .java file into .class file by using Compiler (.class is nothing but byte code file.) and Interpreter reads byte codes.</p>
<p>&nbsp;</p>
<p><strong>How can I swap two variables without using a third variable?</strong></p>
<p>dd two variables and assign the value into First variable. Subtract the Second value with the result Value. and assign to Second variable. Subtract the Result of First Variable With Result of Second Variable and Assign to First Variable. Example:</p>
<table width="820">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="786">
<p>int a=5,b=10;a=a+b; b=a-b; a=a-b;</p>
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p><strong>What is transient variable?</strong></p>
<p>Transient variable can&rsquo;t be serialize. For example if a variable is declared as transient in a Serializable class and the class is written to an ObjectStream, the value of the variable can&rsquo;t be written to the stream instead when the class is retrieved from the ObjectStream the value of the variable becomes&nbsp;<strong>null</strong>.</p>
<p>&nbsp;</p>
<p><strong>Shadowing of static functions in Java</strong></p>
<p>In Java, if the name of a derived class static function is the same as a base class static function then the base class static function shadows (or conceals) the derived class static function. For example, the following Java code prints&nbsp;<em>&ldquo;A.fun()&rdquo;</em><br /> Note: Static method is a class property, so if a static method is called from a class name or object having a class container then the method of that class is called not the object&rsquo;s method.</p>
<p>// file name: Main.java</p>
<p>&nbsp;&nbsp;</p>
<p>// Parent class</p>
<p>class A {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static void fun()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("A.fun()");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;&nbsp;</p>
<p>// B is inheriting A</p>
<p>// Base class</p>
<p>class B extends A {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;static void fun()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("B.fun()");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;&nbsp;</p>
<p>// Driver Method</p>
<p>public class Main {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String args[])</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A a = new B();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.fun(); // prints A.fun();</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// B a = new B();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a.fun(); // prints B.fun()</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the variable type decides the method</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// being invoked, not the assigned object type</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>&nbsp;</p>
<p><strong>Output:</strong></p>
<p>A.fun()</p>
<p><strong>Note:&nbsp;</strong>If we make both A.fun() and B.fun() as non-static then the above program would print &ldquo;B.fun()&rdquo;. While both methods are static types, the variable type decides the method being invoked, not the assigned object type</p>
<p>&nbsp;</p>
<h1>Strings in Java</h1>
<p>Strings in Java are Objects that are backed internally by a char array. Since arrays are immutable(cannot grow), Strings are immutable as well. Whenever a change to a String is made, an entirely new String is created.</p>
<p><a href="https://www.geeksforgeeks.org/string-class-in-java/">String</a>: String is a sequence of characters. In java, objects of String are immutable which means a constant and cannot be changed once created.</p>
<p><strong>Creating a String</strong></p>
<p>There are two ways to create string in Java:</p>
<ul>
<li><strong><em>String literal</em></strong></li>
</ul>
<p>String s = &ldquo;GeeksforGeeks&rdquo;;</p>
<ul>
<li><strong>Using&nbsp;<em>new</em>keyword</strong></li>
</ul>
<p>String s = new String (&ldquo;GeeksforGeeks&rdquo;);</p>
<p>&nbsp;</p>
<p><strong><sub>Memory allotment of String</sub></strong></p>
<p>Whenever a String Object is created, two objects will be created- one in the Heap Area and one in the String constant pool and the String object reference always points to heap area object.</p>