<!DOCTYPE html>
<html>
<body>

<button type="button" onclick="document.location='index.html'" style="position:fixed;">Back To HOME</button>
<br>



<h1>Collections&nbsp;</h1>
<p>The&nbsp;<strong>Collection in Java</strong>&nbsp;is a framework that provides an architecture to store and manipulate the group of objects.</p>
<p>Java Collections can achieve all the operations that you perform on a data such as searching, sorting, insertion, manipulation, and deletion.</p>
<p>Java Collection means a single unit of objects. Java Collection framework provides many interfaces (Set, List, Queue, Deque) and classes (<a href="https://www.javatpoint.com/java-arraylist">ArrayList</a>, Vector,&nbsp;<a href="https://www.javatpoint.com/java-linkedlist">LinkedList</a>,&nbsp;<a href="https://www.javatpoint.com/java-priorityqueue">PriorityQueue</a>, HashSet, LinkedHashSet, TreeSet).</p>
<p>A Collection is a group of individual objects represented as a single unit. Java provides Collection Framework which defines several classes and interfaces to represent a group of objects as a single unit.</p>
<p>The Collection interface (<strong>java.util.Collection</strong>) and Map interface (<strong>java.util.Map</strong>) are the two main &ldquo;root&rdquo; interfaces of Java collection classes.</p>
<p><strong>Need for Collection Framework :</strong><br />Before Collection Framework (or before JDK 1.2) was introduced, the standard methods for grouping Java objects (or collections) were Arrays or Vectors or Hashtables. All of these collections had no common interface.</p>
<p>Accessing elements of these Data Structures was a hassle as each had a different method (and syntax) for accessing its members:</p>
<p>// Java program to show why collection framework was needed</p>
<p>import java.io.*;</p>
<p>import java.util.*;</p>
<p>class Test</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main (String[] args)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Creating instances of array, vector and hashtable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int arr[] = new int[] {1, 2, 3, 4};</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&lt;Integer&gt; v = new Vector();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hashtable&lt;Integer, String&gt; h = new Hashtable();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.addElement(1);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.addElement(2);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.put(1,"geeks");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.put(2,"4geeks");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Array instance creation requires [], while Vector</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and hastable require ()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Vector element insertion requires addElement(), but</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// hashtable element insertion requires put()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Accessing first element of array, vector and hashtable</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(arr[0]);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(v.elementAt(0));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(h.get(1));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Array elements are accessed using [], vector elements</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// using elementAt() and hashtable elements using get()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>Output:</p>
<p>1</p>
<p>1</p>
<p>geeks</p>
<p>As we can see, none of these collections (Array, Vector or Hashtable) implement a standard member access interface. It was very difficult for programmers to write algorithms that can work for all kinds of Collections. Another drawback being that most of the &lsquo;Vector&rsquo; methods are final, meaning we cannot extend the &rsquo;Vector&rsquo; class to implement a similar kind of Collection.<br /><strong><em>Java developers decided to come up with a common interface to deal with the above mentioned problems and introduced the Collection Framework in JDK 1.2</em></strong>.</p>
<p>Both legacy Vectors and Hashtables were modified to conform to the Collection Framework.</p>
<p><strong>Advantages of Collection Framework:</strong></p>
<ol>
<li>Consistent API : The API has a basic set of interfaces like Collection, Set, List, or Map. All classes (ArrayList, LinkedList, Vector, etc) that implement these interfaces have&nbsp;<em>some</em>common set of methods.</li>
<li>Reduces programming effort: A programmer doesn&rsquo;t have to worry about the design of Collection, and he can focus on its best use in his program.</li>
<li>Increases program speed and quality: Increases performance by providing high-performance implementations of useful data structures and algorithms.</li>
</ol>
<h4 class="h3">What is Collection in Java</h4>
<p>A Collection represents a single unit of objects, i.e., a group.</p>
<p>A collection is a framework that is used to store and manipulate a container of objects in Java.</p>
<p>Collections can be used for performing a variety of operations such as:</p>
<ul>
<li>Search</li>
<li>Sort</li>
<li>Manipulate</li>
<li>Delete</li>
</ul>
<p>Below is the chart that represents the hierarchy of collections in Java:</p>
<p><img class="aligncenter wp-image-212666 size-full lazyloaded" src="https://intellipaat.com/blog/wp-content/uploads/2015/09/2.jpg" sizes="(max-width: 800px) 100vw, 800px" srcset="https://intellipaat.com/blog/wp-content/uploads/2015/09/2.jpg 800w, https://intellipaat.com/blog/wp-content/uploads/2015/09/2-768x370.jpg 768w, https://intellipaat.com/blog/wp-content/uploads/2015/09/2-561x270.jpg 561w" alt="Collectiions in Java" width="800" height="385" data-lazy-srcset="https://intellipaat.com/blog/wp-content/uploads/2015/09/2.jpg 800w, https://intellipaat.com/blog/wp-content/uploads/2015/09/2-768x370.jpg 768w, https://intellipaat.com/blog/wp-content/uploads/2015/09/2-561x270.jpg 561w" data-lazy-sizes="(max-width: 800px) 100vw, 800px" data-lazy-src="https://intellipaat.com/blog/wp-content/uploads/2015/09/2.jpg" data-was-processed="true" /></p>
<h3 id="h2">Iterator interface</h3>
<table>
<tbody>
<tr>
<td>Iterator interface provides the facility of iterating the elements in a forward direction only.</td>
</tr>
</tbody>
</table>
<h4 class="h4">Methods of Iterator interface</h4>
<p>There are only three methods in the Iterator interface. They are:</p>
<table class="alt">
<tbody>
<tr>
<th>No.</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>public boolean hasNext()</td>
<td>It returns true if the iterator has more elements otherwise it returns false.</td>
</tr>
<tr>
<td>2</td>
<td>public Object next()</td>
<td>It returns the element and moves the cursor pointer to the next element.</td>
</tr>
<tr>
<td>3</td>
<td>public void remove()</td>
<td>It removes the last elements returned by the iterator. It is less used.</td>
</tr>
</tbody>
</table>
<h2 class="h2">Iterable Interface</h2>
<p>The Iterable interface is the root interface for all the collection classes. The Collection interface extends the Iterable interface and therefore all the subclasses of Collection interface also implement the Iterable interface.</p>
<p>It contains only one abstract method. i.e.,</p>
<div class="codeblock">
<div class="dp-highlighter">
<p>&nbsp; &nbsp; &nbsp; Iterator&lt;T&gt; iterator()&nbsp;&nbsp;</p>
</div>
</div>
<p>It returns the iterator over the elements of type T.</p>
<h2 class="h2">Collection Interface</h2>
<p>The Collection interface is the interface which is implemented by all the classes in the collection framework. It declares the methods that every collection will have. In other words, we can say that the Collection interface builds the foundation on which the collection framework depends.</p>
<p>Some of the methods of Collection interface are Boolean add ( Object obj), Boolean addAll ( Collection c), void clear(), etc. which are implemented by all the subclasses of Collection interface.</p>
<h2 class="h2">List Interface</h2>
<p>List interface is the child interface of Collection interface. It inhibits a list type data structure in which we can store the ordered collection of objects. It can have duplicate values.</p>
<p>List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack.</p>
<p>To instantiate the List interface, we must use :</p>
<div class="codeblock">
<div class="dp-highlighter">
<p>List&nbsp;&lt;data-type&gt;&nbsp;list1=&nbsp;new&nbsp;ArrayList();&nbsp;&nbsp;<br />List&nbsp;&lt;data-type&gt;&nbsp;list2&nbsp;=&nbsp;new&nbsp;LinkedList();&nbsp;&nbsp;<br />List&nbsp;&lt;data-type&gt;&nbsp;list3&nbsp;=&nbsp;new&nbsp;Vector();&nbsp;&nbsp;<br />List&nbsp;&lt;data-type&gt;&nbsp;list4&nbsp;=&nbsp;new&nbsp;Stack();&nbsp;&nbsp;</p>
</div>
</div>
<p>There are various methods in List interface that can be used to insert, delete, and access the elements from the list.</p>
<p>The classes that implement the List interface are given below.</p>
<h2 class="h2">ArrayList</h2>
<p>The ArrayList class implements the List interface. It uses a dynamic array to store the duplicate element of different data types. The ArrayList class maintains the insertion order and is non-synchronized. The elements stored in the ArrayList class can be randomly accessed. Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<p>import java.util.*;<br />class TestJavaCollection1 {<br />public static void main(String args[]) {<br />ArrayList &lt; String &gt; list = new ArrayList &lt; String &gt; (); //Creating arraylist<br />list.add("Ravi"); //Adding object in arraylist<br />list.add("Vijay");<br />list.add("Ravi");<br />list.add("Ajay");<br />//Traversing list through Iterator<br />Iterator itr = list.iterator();<br />while (itr.hasNext()) {<br />System.out.println(itr.next());<br />}<br />}<br />}</p>
</div>
</div>
<p>Output:</p>
<div class="codeblock3">
<pre>Ravi
Vijay
Ravi
Ajay</pre>
<h2 class="h2">LinkedList</h2>
<p>LinkedList implements the Collection interface. It uses a doubly linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.</p>
<p>Consider the following example.</p>
<p>import java.util.*; <br />public class TestJavaCollection2{ <br />public static void main(String args[]){ <br />LinkedList&lt;String&gt; al=new LinkedList&lt;String&gt;(); <br />al.add("Ravi"); <br />al.add("Vijay"); <br />al.add("Ravi"); <br />al.add("Ajay"); <br />Iterator&lt;String&gt; itr=al.iterator(); <br />while(itr.hasNext()){ <br />System.out.println(itr.next()); <br />} <br />} <br />}</p>
<p>output:</p>
<pre>Ravi
Vijay
Ravi
Ajay</pre>
<h2 class="h2">Vector</h2>
<p>Vector uses a dynamic array to store the data elements. It is similar to ArrayList. However, It is synchronized and contains many methods that are not the part of Collection framework.</p>
<p>Consider the following example.</p>
<p>import java.util.*; <br />public class TestJavaCollection3{ <br />public static void main(String args[]){ <br />Vector&lt;String&gt; v=new Vector&lt;String&gt;(); <br />v.add("Ayush"); <br />v.add("Amit"); <br />v.add("Ashish"); <br />v.add("Garima"); <br />Iterator&lt;String&gt; itr=v.iterator(); <br />while(itr.hasNext()){ <br />System.out.println(itr.next()); <br />} <br />} <br />}</p>
<p>Output:</p>
<div class="codeblock3">
<pre>Ayush
Amit
Ashish
Garima</pre>
<h2 class="h2">Stack</h2>
<p>The stack is the subclass of Vector. It implements the last-in-first-out data structure, i.e., Stack. The stack contains all of the methods of Vector class and also provides its methods like boolean push(), boolean peek(), boolean push(object o), which defines its properties.</p>
<p>Consider the following example.</p>
<p>import java.util.*; <br />public class TestJavaCollection4{ <br />public static void main(String args[]){ <br />Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); <br />stack.push("Ayush"); <br />stack.push("Garvit"); <br />stack.push("Amit"); <br />stack.push("Ashish"); <br />stack.push("Garima"); <br />stack.pop(); <br />Iterator&lt;String&gt; itr=stack.iterator(); <br />while(itr.hasNext()){ <br />System.out.println(itr.next()); <br />} <br />} <br />}</p>
<p>Output:</p>
<div class="codeblock3">
<pre>Ayush
Garvit
Amit
Ashish</pre>
<h2 class="h2">Queue Interface</h2>
<p>Queue interface maintains the first-in-first-out order. It can be defined as an ordered list that is used to hold the elements which are about to be processed. There are various classes like PriorityQueue, Deque, and ArrayDeque which implements the Queue interface.</p>
<p>Queue interface can be instantiated as:</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">Queue&lt;String&gt;&nbsp;q1&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;PriorityQueue();&nbsp;&nbsp;</li>
<li class="">Queue&lt;String&gt;&nbsp;q2&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayDeque();&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>There are various classes that implement the Queue interface, some of them are given below.</p>
<h2 class="h2">PriorityQueue</h2>
<p>The PriorityQueue class implements the Queue interface. It holds the elements or objects which are to be processed by their priorities. PriorityQueue doesn't allow null values to be stored in the queue.</p>
<p>Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.*;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;TestJavaCollection5{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
<li class="">PriorityQueue&lt;String&gt;&nbsp;queue=<span class="keyword">new</span>&nbsp;PriorityQueue&lt;String&gt;();&nbsp;&nbsp;</li>
<li class="alt">queue.add(<span class="string">"Amit&nbsp;Sharma"</span>);&nbsp;&nbsp;</li>
<li class="">queue.add(<span class="string">"Vijay&nbsp;Raj"</span>);&nbsp;&nbsp;</li>
<li class="alt">queue.add(<span class="string">"JaiShankar"</span>);&nbsp;&nbsp;</li>
<li class="">queue.add(<span class="string">"Raj"</span>);&nbsp;&nbsp;</li>
<li class="alt">System.out.println(<span class="string">"head:"</span>+queue.element());&nbsp;&nbsp;</li>
<li class="">System.out.println(<span class="string">"head:"</span>+queue.peek());&nbsp;&nbsp;</li>
<li class="alt">System.out.println(<span class="string">"iterating&nbsp;the&nbsp;queue&nbsp;elements:"</span>);&nbsp;&nbsp;</li>
<li class="">Iterator&nbsp;itr=queue.iterator();&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">while</span>(itr.hasNext()){&nbsp;&nbsp;</li>
<li class="">System.out.println(itr.next());&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
<li class="">queue.remove();&nbsp;&nbsp;</li>
<li class="alt">queue.poll();&nbsp;&nbsp;</li>
<li class="">System.out.println(<span class="string">"after&nbsp;removing&nbsp;two&nbsp;elements:"</span>);&nbsp;&nbsp;</li>
<li class="alt">Iterator&lt;String&gt;&nbsp;itr2=queue.iterator();&nbsp;&nbsp;</li>
<li class=""><span class="keyword">while</span>(itr2.hasNext()){&nbsp;&nbsp;</li>
<li class="alt">System.out.println(itr2.next());&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Output:</p>
<div class="codeblock3">
<pre>head:Amit Sharma
head:Amit Sharma
iterating the queue elements:
Amit Sharma
Raj
JaiShankar
Vijay Raj
after removing two elements:
Raj
Vijay Raj
</pre>
</div>
<h2 class="h2">Deque Interface</h2>
<p>Deque interface extends the Queue interface. In Deque, we can remove and add the elements from both the side. Deque stands for a double-ended queue which enables us to perform the operations at both the ends.</p>
<p>Deque can be instantiated as:</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">Deque&nbsp;d&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayDeque();&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<h2 class="h2">ArrayDeque</h2>
<p>ArrayDeque class implements the Deque interface. It facilitates us to use the Deque. Unlike queue, we can add or delete the elements from both the ends.</p>
<p>ArrayDeque is faster than ArrayList and Stack and has no capacity restrictions.</p>
<p>Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">
<div class="tools">&nbsp;</div>
</div>
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.*;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;TestJavaCollection6{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
<li class=""><span class="comment">//Creating&nbsp;Deque&nbsp;and&nbsp;adding&nbsp;elements</span>&nbsp;&nbsp;</li>
<li class="alt">Deque&lt;String&gt;&nbsp;deque&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayDeque&lt;String&gt;();&nbsp;&nbsp;</li>
<li class="">deque.add(<span class="string">"Gautam"</span>);&nbsp;&nbsp;</li>
<li class="alt">deque.add(<span class="string">"Karan"</span>);&nbsp;&nbsp;</li>
<li class="">deque.add(<span class="string">"Ajay"</span>);&nbsp;&nbsp;</li>
<li class="alt"><span class="comment">//Traversing&nbsp;elements</span>&nbsp;&nbsp;</li>
<li class=""><span class="keyword">for</span>&nbsp;(String&nbsp;str&nbsp;:&nbsp;deque)&nbsp;{&nbsp;&nbsp;</li>
<li class="alt">System.out.println(str);&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Output:</p>
<div class="codeblock3">
<pre>Gautam
Karan
Ajay
</pre>
</div>
<h2 class="h2">Set Interface</h2>
<p>Set Interface in Java is present in java.util package. It extends the Collection interface. It represents the unordered set of elements which doesn't allow us to store the duplicate items. We can store at most one null value in Set. Set is implemented by HashSet, LinkedHashSet, and TreeSet.</p>
<p>Set can be instantiated as:</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">Set&lt;data-type&gt;&nbsp;s1&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;HashSet&lt;data-type&gt;();&nbsp;&nbsp;</li>
<li class="">Set&lt;data-type&gt;&nbsp;s2&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;LinkedHashSet&lt;data-type&gt;();&nbsp;&nbsp;</li>
<li class="alt">Set&lt;data-type&gt;&nbsp;s3&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;TreeSet&lt;data-type&gt;();&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<h2 class="h2">HashSet</h2>
<p>HashSet class implements Set Interface. It represents the collection that uses a hash table for storage. Hashing is used to store the elements in the HashSet. It contains unique items.</p>
<p>Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.*;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;TestJavaCollection7{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
<li class=""><span class="comment">//Creating&nbsp;HashSet&nbsp;and&nbsp;adding&nbsp;elements</span>&nbsp;&nbsp;</li>
<li class="alt">HashSet&lt;String&gt;&nbsp;set=<span class="keyword">new</span>&nbsp;HashSet&lt;String&gt;();&nbsp;&nbsp;</li>
<li class="">set.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="alt">set.add(<span class="string">"Vijay"</span>);&nbsp;&nbsp;</li>
<li class="">set.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="alt">set.add(<span class="string">"Ajay"</span>);&nbsp;&nbsp;</li>
<li class=""><span class="comment">//Traversing&nbsp;elements</span>&nbsp;&nbsp;</li>
<li class="alt">Iterator&lt;String&gt;&nbsp;itr=set.iterator();&nbsp;&nbsp;</li>
<li class=""><span class="keyword">while</span>(itr.hasNext()){&nbsp;&nbsp;</li>
<li class="alt">System.out.println(itr.next());&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Output:</p>
<div class="codeblock3">
<pre>Vijay
Ravi
Ajay
</pre>
</div>
<h2 class="h2">LinkedHashSet</h2>
<p>LinkedHashSet class represents the LinkedList implementation of Set Interface. It extends the HashSet class and implements Set interface. Like HashSet, It also contains unique elements. It maintains the insertion order and permits null elements.</p>
<p>Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.*;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;TestJavaCollection8{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
<li class="">LinkedHashSet&lt;String&gt;&nbsp;set=<span class="keyword">new</span>&nbsp;LinkedHashSet&lt;String&gt;();&nbsp;&nbsp;</li>
<li class="alt">set.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="">set.add(<span class="string">"Vijay"</span>);&nbsp;&nbsp;</li>
<li class="alt">set.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="">set.add(<span class="string">"Ajay"</span>);&nbsp;&nbsp;</li>
<li class="alt">Iterator&lt;String&gt;&nbsp;itr=set.iterator();&nbsp;&nbsp;</li>
<li class=""><span class="keyword">while</span>(itr.hasNext()){&nbsp;&nbsp;</li>
<li class="alt">System.out.println(itr.next());&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Output:</p>
<div class="codeblock3">
<pre>Ravi
Vijay
Ajay
</pre>
</div>
<h2 class="h2">SortedSet Interface</h2>
<p>SortedSet is the alternate of Set interface that provides a total ordering on its elements. The elements of the SortedSet are arranged in the increasing (ascending) order. The SortedSet provides the additional methods that inhibit the natural ordering of the elements.</p>
<p>The SortedSet can be instantiated as:</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">SortedSet&lt;data-type&gt;&nbsp;set&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;TreeSet();&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<h2 class="h2">TreeSet</h2>
<p>Java TreeSet class implements the Set interface that uses a tree for storage. Like HashSet, TreeSet also contains unique elements. However, the access and retrieval time of TreeSet is quite fast. The elements in TreeSet stored in ascending order.</p>
<p>Consider the following example:</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.*;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;TestJavaCollection9{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
<li class=""><span class="comment">//Creating&nbsp;and&nbsp;adding&nbsp;elements</span>&nbsp;&nbsp;</li>
<li class="alt">TreeSet&lt;String&gt;&nbsp;set=<span class="keyword">new</span>&nbsp;TreeSet&lt;String&gt;();&nbsp;&nbsp;</li>
<li class="">set.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="alt">set.add(<span class="string">"Vijay"</span>);&nbsp;&nbsp;</li>
<li class="">set.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="alt">set.add(<span class="string">"Ajay"</span>);&nbsp;&nbsp;</li>
<li class=""><span class="comment">//traversing&nbsp;elements</span>&nbsp;&nbsp;</li>
<li class="alt">Iterator&lt;String&gt;&nbsp;itr=set.iterator();&nbsp;&nbsp;</li>
<li class=""><span class="keyword">while</span>(itr.hasNext()){&nbsp;&nbsp;</li>
<li class="alt">System.out.println(itr.next());&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Output:</p>
<pre>Ajay
Ravi
Vijay</pre>
<h3 class="h3">Ways to iterate the elements of the collection in Java</h3>
<p>There are various ways to traverse the collection elements:</p>
<ol class="points">
<li>By Iterator interface.</li>
<li>By for-each loop.</li>
<li>By ListIterator interface.</li>
<li>By for loop.</li>
<li>By forEach() method.</li>
<li>By forEachRemaining() method.</li>
</ol>
<h3 class="h3">Iterating Collection through remaining ways</h3>
<p>Let's see an example to traverse the ArrayList elements through other ways</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.*;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">class</span>&nbsp;ArrayList4{&nbsp;&nbsp;</li>
<li class="alt">&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;ArrayList&lt;String&gt;&nbsp;list=<span class="keyword">new</span>&nbsp;ArrayList&lt;String&gt;();<span class="comment">//Creating&nbsp;arraylist</span>&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="string">"Ravi"</span>);<span class="comment">//Adding&nbsp;object&nbsp;in&nbsp;arraylist</span>&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="string">"Vijay"</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="string">"Ravi"</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="string">"Ajay"</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"Traversing&nbsp;list&nbsp;through&nbsp;List&nbsp;Iterator:"</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Here,&nbsp;element&nbsp;iterates&nbsp;in&nbsp;reverse&nbsp;order</span>&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListIterator&lt;String&gt;&nbsp;list1=list.listIterator(list.size());&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(list1.hasPrevious())&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str=list1.previous();&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"Traversing&nbsp;list&nbsp;through&nbsp;for&nbsp;loop:"</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>(<span class="keyword">int</span>&nbsp;i=<span class="number">0</span>;i&lt;list.size();i++)&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(list.get(i));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"Traversing&nbsp;list&nbsp;through&nbsp;forEach()&nbsp;method:"</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//The&nbsp;forEach()&nbsp;method&nbsp;is&nbsp;a&nbsp;new&nbsp;feature,&nbsp;introduced&nbsp;in&nbsp;Java&nbsp;8.</span>&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.forEach(a-&gt;{&nbsp;<span class="comment">//Here,&nbsp;we&nbsp;are&nbsp;using&nbsp;lambda&nbsp;expression</span>&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"Traversing&nbsp;list&nbsp;through&nbsp;forEachRemaining()&nbsp;method:"</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;String&gt;&nbsp;itr=list.iterator();&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itr.forEachRemaining(a-&gt;&nbsp;<span class="comment">//Here,&nbsp;we&nbsp;are&nbsp;using&nbsp;lambda&nbsp;expression</span>&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;</li>
<li class="">&nbsp;}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>Output:</strong></p>
<div class="codeblock3">
<pre>Traversing list through List Iterator:
Ajay
Ravi
Vijay
Ravi
Traversing list through for loop:
Ravi
Vijay
Ravi
Ajay
Traversing list through forEach() method:
Ravi
Vijay
Ravi
Ajay
Traversing list through forEachRemaining() method:
Ravi
Vijay
Ravi
Ajay
</pre>
<h3 class="h3">What is the difference between Collection and Collections?</h3>
<p>The differences between the Collection and Collections are given below.</p>
<ul class="points">
<li>The Collection is an interface whereas Collections is a class.</li>
<li>The Collection interface provides the standard functionality of data structure to List, Set, and Queue. However, Collections class is to sort and synchronize the collection elements.</li>
<li>The Collection interface provides the methods that can be used for data structure whereas Collections class provides the static methods which can be used for various operation on a collection.</li>
</ul>
<h3 class="h3">What are the main differences between array and collection?</h3>
<p>Array and Collection are somewhat similar regarding storing the references of objects and manipulating the data, but they differ in many ways. The main differences between the array and Collection are defined below:</p>
<ul class="points">
<li>Arrays are always of fixed size, i.e., a user can not increase or decrease the length of the array according to their requirement or at runtime, but In Collection, size can be changed dynamically as per need.</li>
<li>Arrays can only store homogeneous or similar type objects, but in Collection, heterogeneous objects can be stored.</li>
<li>Arrays cannot provide the ?ready-made? methods for user requirements as sorting, searching, etc. but Collection includes readymade methods to use.</li>
</ul>
<h3 class="h3">Explain various interfaces used in Collection framework?</h3>
<p>Collection framework implements various interfaces, Collection interface and Map interface (java.util.Map) are the mainly used interfaces of Java Collection Framework. List of interfaces of Collection Framework is given below:</p>
<p><strong>1. Collection interface:</strong>&nbsp;Collection (java.util.Collection) is the primary interface, and every collection must implement this interface.</p>
<p><strong>Syntax:</strong></p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;Collection&lt;E&gt;<span class="keyword">extends</span>&nbsp;Iterable&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Where &lt;E&gt; represents that this interface is of Generic type</p>
<p><strong>2. List interface:&nbsp;</strong>List interface extends the Collection interface, and it is an ordered collection of objects. It contains duplicate elements. It also allows random access of elements.</p>
<p><strong>Syntax:</strong></p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;List&lt;E&gt;&nbsp;<span class="keyword">extends</span>&nbsp;Collection&lt;E&gt;&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>3. Set interface:</strong>&nbsp;Set (java.util.Set) interface is a collection which cannot contain duplicate elements. It can only include inherited methods of Collection interface</p>
<p><strong>Syntax:</strong></p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;Set&lt;E&gt;&nbsp;<span class="keyword">extends</span>&nbsp;Collection&lt;E&gt;&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>Queue interface:&nbsp;</strong>Queue (java.util.Queue) interface defines queue data structure, which stores the elements in the form FIFO (first in first out).</p>
<p><strong>Syntax:</strong></p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;Queue&lt;E&gt;&nbsp;<span class="keyword">extends</span>&nbsp;Collection&lt;E&gt;&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>4. Dequeue interface:</strong>&nbsp;it is a double-ended-queue. It allows the insertion and removal of elements from both ends. It implants the properties of both Stack and queue so it can perform LIFO (Last in first out) stack and FIFO (first in first out) queue, operations.</p>
<p><strong>Syntax:</strong></p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;Dequeue&lt;E&gt;&nbsp;<span class="keyword">extends</span>&nbsp;Queue&lt;E&gt;&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>5. Map interface:&nbsp;</strong>A Map (java.util.Map) represents a key, value pair storage of elements. Map interface does not implement the Collection interface. It can only contain a unique key but can have duplicate elements. There are two interfaces which implement Map in java that are Map interface and Sorted Map.</p>
<h3 class="h3">What is the difference between ArrayList and Vector?</h3>
<table class="alt">
<tbody>
<tr>
<th>No.</th>
<th>ArrayList</th>
<th>Vector</th>
</tr>
<tr>
<td>1)</td>
<td>ArrayList is not synchronized.</td>
<td>Vector is synchronized.</td>
</tr>
<tr>
<td>2)</td>
<td>ArrayList is not a legacy class.</td>
<td>Vector is a legacy class.</td>
</tr>
<tr>
<td>3)</td>
<td>ArrayList increases its size by 50% of the array size.</td>
<td>Vector increases its size by doubling the array size.</td>
</tr>
<tr>
<td>4)</td>
<td>ArrayList is not ?thread-safe? as it is not synchronized.</td>
<td>Vector list is ?thread-safe? as it?s every method is synchronized.</td>
</tr>
</tbody>
</table>
<h3 class="h3">What is the difference between ArrayList and LinkedList?</h3>
<table class="alt">
<tbody>
<tr>
<th>No.</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
<tr>
<td>1)</td>
<td>ArrayList uses a dynamic array.</td>
<td>LinkedList uses a doubly linked list.</td>
</tr>
<tr>
<td>2)</td>
<td>ArrayList is not efficient for manipulation because too much is required.</td>
<td>LinkedList is efficient for manipulation.</td>
</tr>
<tr>
<td>3)</td>
<td>ArrayList is better to store and fetch data.</td>
<td>LinkedList is better to manipulate data.</td>
</tr>
<tr>
<td>4)</td>
<td>ArrayList provides random access.</td>
<td>LinkedList does not provide random access.</td>
</tr>
<tr>
<td>5)</td>
<td>ArrayList takes less memory overhead as it stores only object</td>
<td>LinkedList takes more memory overhead, as it stores the object as well as the address of that object.</td>
</tr>
</tbody>
</table>
<h4 id="q2-what-is-the-difference-in-arraylist-and-linkedlist">&nbsp;</h4>
<table width="572">
<thead>
<tr>
<th align="left">&nbsp;</th>
<th align="left"><code>ArrayList</code></th>
<th align="left"><code>LinkedList</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">1.</td>
<td align="left">ArrayList implements&nbsp;<em>List</em>&nbsp;and&nbsp;<em>RandomAccess</em>&nbsp;interfaces</td>
<td align="left">LinkedList implements&nbsp;<em>List</em>&nbsp;and&nbsp;<em>Deque</em>&nbsp;interface</td>
</tr>
<tr>
<td align="left">2.</td>
<td align="left">ArrayList internally uses a&nbsp;<strong>dynamic array</strong>&nbsp;to store the elements.</td>
<td align="left">LinkedList internally uses a&nbsp;<strong>doubly linked list</strong>&nbsp;to store the elements.</td>
</tr>
<tr>
<td align="left">3.</td>
<td align="left">ArrayList elements are stored in&nbsp;<strong>contiguous memory location</strong>&nbsp;where each memory location represents an index</td>
<td align="left">Each LinkedList element can be stored at&nbsp;<strong>different memory location</strong>&nbsp;where each element has address of it previous and next element.</td>
</tr>
<tr>
<td align="left">4.</td>
<td align="left"><strong>Insertion and Deletion of elements is slow</strong>&nbsp;in ArrayList as these operations require all the elements to shift by one index to either make the space or fill the empty space</td>
<td align="left"><strong>Insertion and Deletion of elements is faster</strong>&nbsp;in LinkedList as these operations just require to change the addresses in previous and next block</td>
</tr>
<tr>
<td align="left">5.</td>
<td align="left"><strong>Read operation of random element is much faster</strong>&nbsp;in ArrayList due to indices and support of fast random access</td>
<td align="left"><strong>Read operation of random element in slower</strong>&nbsp;in LinkedList as need to traverse the list of find element</td>
</tr>
<tr>
<td align="left">6.</td>
<td align="left">
<p><strong>Recommended when read operation is more</strong>&nbsp;than the number of insertions and deletions</p>
</td>
<td align="left">
<p><strong>Recommended when insertion and deletion rate is higher</strong>&nbsp;then the read operation</p>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>ArrayList:</strong>&nbsp;Many of the operations need n/2 steps on average, constant number of steps in the best case (end of list), n steps in the worst case (start of list)</li>
<li><strong>LinkedList:</strong>&nbsp;Many of the operations need n/4 steps on average, constant number of steps in the best case (e.g. index = 0), and n/2 steps in worst case (middle of list)</li>
</ul>
<h3 class="h3">What is the difference between Iterator and ListIterator?</h3>
<p>Iterator traverses the elements in the forward direction only whereas ListIterator traverses the elements into forward and backward direction.</p>
<table class="alt">
<tbody>
<tr>
<th>No.</th>
<th>Iterator</th>
<th>ListIterator</th>
</tr>
<tr>
<td>1)</td>
<td>The Iterator traverses the elements in the forward direction only.</td>
<td>ListIterator traverses the elements in backward and forward directions both.</td>
</tr>
<tr>
<td>2)</td>
<td>The Iterator can be used in List, Set, and Queue.</td>
<td>ListIterator can be used in List only.</td>
</tr>
<tr>
<td>3)</td>
<td>The Iterator can only perform remove operation while traversing the collection.</td>
<td>
<p>ListIterator can perform ?add,? ?remove,? and ?set? operation while traversing the collection.</p>
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<h3 class="h3">What is the difference between Iterator and Enumeration?</h3>
<table class="alt">
<tbody>
<tr>
<th>No.</th>
<th>Iterator</th>
<th>Enumeration</th>
</tr>
<tr>
<td>1)</td>
<td>The Iterator can traverse legacy and non-legacy elements.</td>
<td>Enumeration can traverse only legacy elements.</td>
</tr>
<tr>
<td>2)</td>
<td>The Iterator is fail-fast.</td>
<td>Enumeration is not fail-fast.</td>
</tr>
<tr>
<td>3)</td>
<td>The Iterator is slower than Enumeration.</td>
<td>Enumeration is faster than Iterator.</td>
</tr>
<tr>
<td>4)</td>
<td>The Iterator can perform remove operation while traversing the collection.</td>
<td>The Enumeration can perform only traverse operation on the collection.</td>
</tr>
</tbody>
</table>
<h3 class="h3">What is the difference between List and Set?</h3>
<p>The List and Set both extend the collection interface. However, there are some differences between the both which are listed below.</p>
<ul class="points">
<li>The List can contain duplicate elements whereas Set includes unique items.</li>
<li>The List is an ordered collection which maintains the insertion order whereas Set is an unordered collection which does not preserve the insertion order.</li>
<li>The List interface contains a single legacy class which is Vector class whereas Set interface does not have any legacy class.</li>
<li>The List interface can allow n number of null values whereas Set interface only allows a single null value.</li>
</ul>
<h3 class="h3">What is the difference between HashSet and TreeSet?</h3>
<p>The HashSet and TreeSet, both classes, implement Set interface. The differences between the both are listed below.</p>
<ul class="points">
<li>HashSet maintains&nbsp;no order&nbsp;whereas TreeSet maintains&nbsp;ascending order.</li>
<li>HashSet impended by hash table whereas TreeSet implemented by a Tree structure.</li>
<li>HashSet performs faster than TreeSet.</li>
<li>HashSet is backed by HashMap whereas TreeSet is backed by TreeMap.</li>
</ul>
<h3 class="h3">What is the difference between Set and Map?</h3>
<p>The differences between the Set and Map are given below.</p>
<ul class="points">
<li>Set contains values only whereas Map contains key and values both.</li>
<li>Set contains unique values whereas Map can contain unique Keys with duplicate values.</li>
<li>Set holds a single number of null value whereas Map can include a single null key with n number of null values.</li>
</ul>
<h3 class="h3">What is the difference between HashSet and HashMap?</h3>
<p>The differences between the HashSet and HashMap are listed below.</p>
<ul class="points">
<li>HashSet contains only values whereas HashMap includes the entry (key, value). HashSet can be iterated, but HashMap needs to convert into Set to be iterated.</li>
<li>HashSet implements Set interface whereas HashMap implements the Map interface</li>
<li>HashSet cannot have any duplicate value whereas HashMap can contain duplicate values with unique keys.</li>
<li>HashSet contains the only single number of null value whereas HashMap can hold a single null key with n number of null values.</li>
</ul>
<h3 class="h3">What is the difference between HashMap and TreeMap?</h3>
<p>The differences between the HashMap and TreeMap are given below.</p>
<ul class="points">
<li>HashMap maintains&nbsp;no order, but TreeMap maintains&nbsp;ascending order.</li>
<li>HashMap is implemented by hash table whereas TreeMap is implemented by a Tree structure.</li>
<li>HashMap can be sorted by Key or value whereas TreeMap can be sorted by Key.</li>
<li>HashMap may contain a null key with multiple null values whereas TreeMap cannot hold a null key but can have multiple null values.</li>
</ul>
<h3 class="h3">What is the difference between HashMap and Hashtable?</h3>
<table class="alt" style="width: 429px;">
<tbody>
<tr>
<th style="width: 28.7292px;">No.</th>
<th style="width: 190.917px;">HashMap</th>
<th style="width: 187.354px;">Hashtable</th>
</tr>
<tr>
<td style="width: 28.7292px;">1)</td>
<td style="width: 190.917px;">HashMap is not synchronized.</td>
<td style="width: 187.354px;">Hashtable is synchronized.</td>
</tr>
<tr>
<td style="width: 28.7292px;">2)</td>
<td style="width: 190.917px;">HashMap can contain one null key and multiple null values.</td>
<td style="width: 187.354px;">Hashtable cannot contain any null key or null value.</td>
</tr>
<tr>
<td style="width: 28.7292px;">3)</td>
<td style="width: 190.917px;">HashMap is not ?thread-safe,? so it is useful for non-threaded applications.</td>
<td style="width: 187.354px;">Hashtable is thread-safe, and it can be shared between various threads.</td>
</tr>
<tr>
<td style="width: 28.7292px;">4)</td>
<td style="width: 190.917px;">4) HashMap inherits the AbstractMap class</td>
<td style="width: 187.354px;">Hashtable inherits the Dictionary class.</td>
</tr>
</tbody>
</table>
<p class="h3">There are many differences between these two classes, some of them are following:<br />a) Hashtable is a legacy class and present from JDK 1, HashMap was added later.<br />b) Hashtable is synchronized and slower but HashMap is not synchronized and faster.<br />c) Hashtable doesn't allow null keys but HashMap allows one null key.&nbsp;</p>
<h3 class="h3"><a href="https://www.javatpoint.com/array-vs-arraylist-in-java">What is the difference between Array and ArrayList?</a></h3>
<p>The main differences between the Array and ArrayList are given below.</p>
<table class="alt">
<tbody>
<tr>
<th>SN</th>
<th>Array</th>
<th>ArrayList</th>
</tr>
<tr>
<td>1</td>
<td>The Array is of fixed size, means we cannot resize the array as per need.</td>
<td>ArrayList is not of the fixed size we can change the size dynamically.</td>
</tr>
<tr>
<td>2</td>
<td>Arrays are of the static type.</td>
<td>ArrayList is of dynamic size.</td>
</tr>
<tr>
<td>3</td>
<td>Arrays can store primitive data types as well as objects.</td>
<td>ArrayList cannot store the primitive data types it can only store the objects.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<p>----------------------------------------------------------------------------</p>
<h3 class="h3">What is the difference between Comparable and Comparator?</h3>
<table class="alt">
<tbody>
<tr>
<th>No.</th>
<th>Comparable</th>
<th>Comparator</th>
</tr>
<tr>
<td>1)</td>
<td>Comparable provides only one sort of sequence.</td>
<td>The Comparator provides multiple sorts of sequences.</td>
</tr>
<tr>
<td>2)</td>
<td>It provides one method named compareTo().</td>
<td>It provides one method named compare().</td>
</tr>
<tr>
<td>3)</td>
<td>It is found in java.lang package.</td>
<td>It is located in java.util package.</td>
</tr>
<tr>
<td>4)</td>
<td>If we implement the Comparable interface, The actual class is modified.</td>
<td>T</td>
</tr>
</tbody>
</table>
<p><a href="https://www.javatpoint.com/difference-between-comparable-and-comparator" target="_blank">https://www.javatpoint.com/difference-between-comparable-and-comparator</a></p>
<p><strong><em>To summarize, if sorting of objects needs to be based on natural order then use Comparable whereas if you sorting needs to be done on attributes of different objects, then use Comparator in Java.</em></strong></p>
<p><strong>What is Comparable and Comparator interface?</strong><br />Java provides Comparable interface which should be implemented by any custom class if we want to use Arrays or Collections sorting methods. Comparable interface has compareTo(T obj) method which is used by sorting methods. We should override this method in such a way that it returns a negative integer, zero, or a positive integer if &ldquo;this&rdquo; object is less than, equal to, or greater than the object passed as argument.<br />But, in most real life scenarios, we want sorting based on different parameters. For example, as a CEO, I would like to sort the employees based on Salary, an HR would like to sort them based on the age. This is the situation where we need to use Comparator interface because Comparable.compareTo(Object o) method implementation can sort based on one field only and we can&rsquo;t chose the field on which we want to sort the Object.<br />Comparator interface compare(Object o1, Object o2) method need to be implemented that takes two Object argument, it should be implemented in such a way that it returns negative int if first argument is less than the second one and returns zero if they are equal and positive int if first argument is greater than second one.</p>
<p>----------------------------------------------------------------------------</p>
<h3 class="h3">What do you understand by fail-fast?</h3>
<p>The Iterator in java which immediately throws ConcurrentmodificationException, if any structural modification occurs in, is called as a Fail-fast iterator. Fail-fats iterator does not require any extra space in memory.</p>
<p>&nbsp;</p>
<p>=====================================</p>
<p><a href="https://www.javatpoint.com/java-collections-interview-questions" target="_blank">https://www.javatpoint.com/java-collections-interview-questions</a></p>
<p>==================================</p>
<h3 class="h3">What is the advantage of the generic collection?</h3>
<p>There are three main advantages of using the generic collection.</p>
<ul class="points">
<li>If we use the generic class, we don't need typecasting.</li>
<li>It is type-safe and checked at compile time.</li>
<li>Generic confirms the stability of the code by making it bug detectable at compile time.</li>
</ul>
<h3 class="h3">What is the Dictionary class?</h3>
<p>The Dictionary class provides the capability to store key-value pairs.</p>
<h3 class="h3">What is the default size of load factor in hashing based collection?</h3>
<p>The default size of load factor is&nbsp;<strong>0.75</strong>. The default capacity is computed as initial capacity * load factor. For example, 16 * 0.75 = 12. So, 12 is the default capacity of Map.</p>
<h3 class="h3"><a href="https://www.javatpoint.com/how-to-convert-arraylist-to-array-and-array-to-arraylist-in-java">How to convert ArrayList to Array and Array to ArrayList?</a></h3>
<p>We can convert an Array to ArrayList by using the asList() method of Arrays class. asList() method is the static method of Arrays class and accepts the List object. Consider the following syntax:</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">Arrays.asList(item)&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>We can convert an ArrayList to Array using toArray() method of the ArrayList class. Consider the following syntax to convert the ArrayList to the List object.</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">List_object.toArray(<span class="keyword">new</span>&nbsp;String[List_object.size()])&nbsp;</li>
</ol>
<h3 class="h3"><a href="https://www.javatpoint.com/how-to-make-java-arraylist-read-only">How to make Java ArrayList Read-Only?</a></h3>
<p>We can obtain java ArrayList Read-only by calling the Collections.unmodifiableCollection() method. When we define an ArrayList as Read-only then we cannot perform any modification in the collection through &nbsp;add(), remove() or set() method.</p>
<h3 class="h3">&nbsp;<a href="https://www.javatpoint.com/how-to-remove-duplicates-from-arraylist-in-java">How to remove duplicates from ArrayList?</a></h3>
<p>There are two ways to remove duplicates from the ArrayList.</p>
<ul class="points">
<li><strong>Using HashSet:</strong>&nbsp;By using HashSet we can remove the duplicate element from the ArrayList, but it will not then preserve the insertion order.</li>
<li><strong>Using LinkedHashSet:</strong>&nbsp;We can also maintain the insertion order by using LinkedHashSet instead of HashSet.</li>
</ul>
<p>The Process to remove duplicate elements from ArrayList using the LinkedHashSet:</p>
<ul class="points">
<li>Copy all the elements of ArrayList to LinkedHashSet.</li>
<li>Empty the ArrayList using clear() method, which will remove all the elements from the list.</li>
<li>Now copy all the elements of LinkedHashset to ArrayList.</li>
</ul>
<h3 class="h3">&nbsp;<a href="https://www.javatpoint.com/how-to-reverse-arraylist-in-java">How to reverse ArrayList?</a></h3>
<p>To reverse an ArrayList, we can use reverse() method of Collections class. Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.ArrayList;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">import</span>&nbsp;java.util.Collection;&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.Collections;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">import</span>&nbsp;java.util.Iterator;&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.List;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ReverseArrayList&nbsp;{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;list&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">10</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">50</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">30</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"printing&nbsp;the&nbsp;list...."</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(i.hasNext())&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i.next());&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i2&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collections.reverse(list);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"printing&nbsp;list&nbsp;in&nbsp;reverse&nbsp;order...."</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(i2.hasNext())&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i2.next());&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
</ol>
<p><strong>Output</strong></p>
<div class="codeblock3">
<pre>printing the list....
10
50
30
printing list in reverse order....
30
50
10<br /><br /></pre>
<h3 class="h3">&nbsp;<a href="https://www.javatpoint.com/how-to-sort-java-arraylist-in-descending-order">How to sort ArrayList in descending order?</a></h3>
<p>To sort the ArrayList in descending order, we can use the reverseOrder method of Collections class. Consider the following example.</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">
<div class="tools">&nbsp;</div>
</div>
<ol class="dp-j" start="1">
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.ArrayList;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">import</span>&nbsp;java.util.Collection;&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.Collections;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">import</span>&nbsp;java.util.Comparator;&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">import</span>&nbsp;java.util.Iterator;&nbsp;&nbsp;</li>
<li class=""><span class="keyword">import</span>&nbsp;java.util.List;&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;</li>
<li class=""><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ReverseArrayList&nbsp;{&nbsp;&nbsp;</li>
<li class="alt"><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;list&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">10</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">50</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">30</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">60</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">20</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.add(<span class="number">90</span>);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"printing&nbsp;the&nbsp;list...."</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(i.hasNext())&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i.next());&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;Comparator&nbsp;cmp&nbsp;=&nbsp;Collections.reverseOrder();&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;Collections.sort(list,cmp);&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"printing&nbsp;list&nbsp;in&nbsp;descending&nbsp;order...."</span>);&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;i2&nbsp;=&nbsp;list.iterator();&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(i2.hasNext())&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i2.next());&nbsp;&nbsp;</li>
<li class="">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</li>
<li class="alt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
<li class="">}&nbsp;&nbsp;</li>
<li class="alt">}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>Output</strong></p>
<div class="codeblock3">
<pre>printing the list....
10
50
30
60
20
90
printing list in descending order....
90
60
50
30
20
10</pre>
<h3 class="h3">&nbsp;<a href="https://www.javatpoint.com/how-to-synchronize-arraylist-in-java">How to synchronize ArrayList?</a></h3>
<p>We can synchronize ArrayList in two ways.</p>
<ul class="points">
<li>Using Collections.synchronizedList() method</li>
<li>Using CopyOnWriteArrayList&lt;T&gt;</li>
</ul>
<h3 class="h3">&nbsp;<a href="https://www.javatpoint.com/when-to-use-arraylist-and-linkedlist-in-java">When to use ArrayList and LinkedList?</a></h3>
<p>LinkedLists are better to use for the update operations whereas ArrayLists are better to use for the search operations.</p>
<p>The obvious difference between them is that ArrrayList is backed by array data structure, supprots random access and LinkedList is backed by linked list data structure and doesn't supprot&nbsp;random access. Accessing an element with the index is O(1) in ArrayList but its O(n) in LinkedList. See the answer for more detailed discussion.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<p><strong>How do WeakHashMap works?&nbsp;</strong><br />WeakHashMap works like a normal HashMap but uses WeakReference for keys, which means if the key object doesn't have any reference then both key/value mapping will become eligible for garbage collection.</p>
<p><strong>What is a.hashCode() used for? How is it related to a.equals(b)?&nbsp;</strong><br />hashCode() method returns an int hash value corresponding to an object. It's used in hash based collection classes e.g Hashtable, HashMap, LinkedHashMap and so on. It's very tightly related to equals() method. According to Java specification, two objects which are equal to each other using equals() method must have same hash code.</p>
<p><strong>What is a couple of ways that you could sort a collection?</strong>&nbsp;<br />You can either use the Sorted collection like TreeSet or TreeMap or you can sort using the ordered collection like a list and using Collections.sort() method.<br /><br /><strong>How do you print Array in Java?</strong>&nbsp;<br />You can print an array by using the Arrays.toString() and Arrays.deepToString() method. Since array doesn't implement toString() by itself, just passing an array to System.out.println() will not print its contents but Arrays.toString() will print each element.</p>
<div><strong>LinkedList in Java is doubly or singly linked list?</strong>&nbsp;<br />It's a doubly linked list, you can check the code in JDK. In Eclipse, you can use the&nbsp;<a href="http://javarevisited.blogspot.com/2010/10/eclipse-tutorial-most-useful-eclipse.html">shortcut</a>, Ctrl&nbsp;+ T to directly open this class in Editor.<br /><br /><strong>Which kind of tree is used to implement TreeMap in Java?</strong>&nbsp;<br />A Red Black tree is used to implement TreeMap in Java.</div>
<div><br /><strong>How HashSet works internally in Java?</strong><br />HashSet is internally implemented using an HashMap. Since a Map needs key and value, a default value is used for all keys. Similar to HashMap, HashSet doesn't allow duplicate keys and only one null key, I mean you can only store one null object in HashSet.</div>
<div>&nbsp;</div>
<div><strong>Write code to remove elements from ArrayList while iterating?</strong><br />&nbsp;Key here is to check whether candidate uses ArrayList's remove() or Iterator's remove(). Here is the&nbsp;<a href="http://java67.blogspot.com/2015/10/how-to-solve-concurrentmodificationexception-in-java-arraylist.html" target="_blank" rel="noopener">sample code</a>&nbsp;which uses right way o remove elements from ArrayList while looping over and avoids ConcurrentModificationException.</div>
<div>&nbsp;</div>
<div><strong>What is default size of ArrayList and HashMap in Java? </strong></div>
<div>As of Java 7 now, default size of ArrayList is 10 and default capacity of HashMap is 16, it must be power of 2. Here is code snippet from ArrayList &nbsp;and HashMap class :<br />
<pre>// from ArrayList.java JDK 1.7
private static final int DEFAULT_CAPACITY = 10;  

//from HashMap.java JDK 7
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</pre>
<strong>Is it possible for two unequal objects to have the same hashcode?</strong><br />Yes, two unequal objects can have same hashcode that's why collision happen in a hashmap.<br />the equal hashcode contract only says that two equal objects must have the same hashcode it doesn't say anything about the unequal object.<br /><br /><strong>Can two equal object have the different hash code?</strong><br />No, thats not possible according to hash code contract.</div>
<div>&nbsp;</div>
<div>--==============================<br /><a href="https://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html#ixzz6X07niR5p">https://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html#ixzz6X07niR5p</a></div>
<p>--==============================</p>
<p><br /><strong>While passing a Collection as argument to a function, how can we make sure the function will not be able to modify it?</strong><br />We can create a read-only collection using Collections.unmodifiableCollection(Collection c) method before passing it as argument, this will make sure that any operation to change the collection will throw UnsupportedOperationException.</p>
<p><strong>Is there a way to increase the size of an array after its declaration?</strong></p>
<p>Arrays are static and once we have specified its size, we can't change it. If we want to use such collections where we may require a change of size ( no of items), we should prefer vector over array.</p>
<h4><strong>Why Map interface does not extend the Collection interface in the Java Collections Framework?</strong></h4>
<p>The Map interface is not compatible with the Collection interface, because Map requires a key as well as a value, for example, if we want to add a key&ndash;value pair, we will use put(Object key, Object value).</p>
<p>There are two parameters required to add an element to HashMap object. In Collection interface, add(Object o) has only one parameter.</p>
<p>The other reasons are: Map supports valueSet, keySet, and other suitable methods that have just different views from the Collection interface.</p>
<h4 id="q3-how-to-find-middle-element-of-linked-list">How to find middle element of Linked List?</h4>
<p><strong>Approach 1: Keep track of the LinkedList size</strong><br />In first approach, we can keep track of size of the linked list. We can have a size counter initialized as zero. Increase or decrease the <a href="https://scorecounter.com/click-counter/" target="_blank">counter</a> by 1, on addition or deletion of nodes from linked list respectively.</p>
<p>In this case, middle element&rsquo;s index will be (size-1)/2</p>
<p><strong>Approach 2: Traverse the LinkedList to find size</strong><br />Sometime we have given only the head node of the linked list and no information about the size.</p>
<p>In simplest approach, we can traverse through whole linked list starting from head till end to find the size of the linked list.</p>
<p>In this case, middle element&rsquo;s index will be (size()-1)/2</p>
<p>If linked list is having n elements, then this approach requires n iteration to get size and n/2 iteration to get middle elements.<br />Total iteration is (n + n/2)</p>
<p><strong>Approach 3: Fast and Slow pointers</strong><br />This approach is also applicable when size of the linked list is unknown and only head node is given.</p>
<p>In this approach, we iterate through the linked list using two pointers. Fast pointer jumps 2 nodes in each iteration, and the slow pointer jumps only one node per iteration.</p>
<p>When the fast pointer reaches the end of the list, the slow pointer will be at the middle element.</p>
<p>This is best approach when size is unknown as we are able to find the middle elements in just n/2 iterations.</p>
<p>Summary<br />We learned that it is always good to keep track of linked list size to find the middle element. Moreover, when size of the linked list is unknown then Fast and slow pointer approach is the way to go.</p>
<p><strong>How to create own HashMap --</strong></p>
<p>https://codingnconcepts.com/java/design-hash-map-in-java/</p>
<h4 id="q4-how-to-find-a-loop-in-linkedlist">How to find a loop in LinkedList?</h4>
<p>If you answer it then follow up question might be asked:</p>
<ul>
<li style="list-style-type: none;">
<ul>
<li>How to find the starting point of loop in LinkedList?</li>
<li>How to find the length of the loop in LinkedList?</li>
</ul>
</li>
</ul>
<p>Collections in Java</p>
<p><a href="https://www.javacodegeeks.com/2013/02/40-java-collections-interview-questions-and-answers.html">https://www.javacodegeeks.com/2013/02/40-java-collections-interview-questions-and-answers.html</a></p>
<h4>Five ways to traverse collections:</h4>
<ol>
<li><strong>By using Iterator</strong></li>
<li><strong>By using ListIterator</strong></li>
<li><strong>By using Enumeration</strong></li>
<li><strong>By using for-each</strong></li>
<li><strong>By using for loop</strong></li>
</ol>
<p><strong>Iterator interface :</strong></p>
<p>Iterator interface used to traverse the elements in forward direction only.</p>
<p><em>Iterator</em>&nbsp;which is used to traverse most of the classes in the collection framework including legacy classes. Iterator can be used in&nbsp;<strong>List, Set , Queue, and Vector etc.</strong></p>
<p>You get an Iterator for a collection by calling its&nbsp;<strong>iterator(</strong>) method.</p>
<p><strong><em>There are three methods in the Iterator interface. They are:</em></strong></p>
<ol>
<li>List&lt;String&gt; obj =<strong>new</strong>&nbsp;ArrayList&lt;String&gt;();</li>
<li>obj.add("Mango");</li>
<li>obj.add("Apple");</li>
<li>&nbsp;</li>
<li>Iterator&lt;String&gt; ite=obj.iterator();//obj is collection object</li>
<li><strong>while</strong>(ite.hasNext())//It returns true if iterator has more elements.</li>
<li>{</li>
<li>System.<strong>out</strong>.println(ite.<strong>next</strong>()); //print the value</li>
<li>}</li>
</ol>
<p><strong>ListIterator interface :</strong></p>
<p>ListIterator interface extends Iterator interface.</p>
<p>ListIterator interface used to traverse the elements in both directions (forward and backward), but reverse apply only for LinkedList elements only.</p>
<p>ListIterator can be used to traverse for&nbsp;<strong>List-type Objects</strong>, but not for Set-type of Objects.</p>
<p>You get a ListIterator for a collection by calling its&nbsp;<strong>listIterator()</strong>&nbsp;method.</p>
<p><strong>There are many methods in the ListIterator interface. But commonly used listed below:</strong></p>
<p>&nbsp;</p>
<ol>
<li>List&lt;String&gt; obj=<strong>new</strong>&nbsp;LinkedList&lt;String&gt;();</li>
<li>obj.add("Mango");</li>
<li>obj.add("Apple");</li>
<li>obj.add("Orange");</li>
<li>&nbsp;</li>
<li>ListIterator lte=obj.listIterator(); //obj is LinkedList object</li>
<li><strong>while</strong>(lte.hasPrevious()) // has previous supports only LinkedList</li>
<li>{</li>
<li>System.<strong>out</strong>.println("&nbsp; "+lte.previous());&nbsp; //print reverse order}</li>
</ol>
<p><strong>Enumeration interface :</strong></p>
<p>The Enumeration interface defines the methods by which you can enumerate (obtain one at a time) the elements in a collection of objects. It supports most of the collections objects.</p>
<p><em>Enumeration</em>&nbsp;is a&nbsp;<strong>legacy interface</strong>&nbsp;used to&nbsp;<strong>traverse only the legacy classes like&nbsp;<em>Vector</em>,&nbsp;<em>HashTable</em>&nbsp;and&nbsp;<em>Stack</em>.</strong></p>
<p>There is only one legacy interface called&nbsp;<strong>Enumeration.</strong></p>
<p>You get an Enumeration for a collection by calling its&nbsp;<strong>elements()</strong>&nbsp;method.</p>
<p><strong>There are two methods in the Enumeration interface. They are:</strong></p>
<ol>
<li>Vector obj=<strong>new</strong>&nbsp;Vector();</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.add("Mango");</li>
<li>obj.add("Apple");</li>
<li>&nbsp;</li>
<li>Enumeration&lt;String&gt; enu=obj.elements(); //obj is Vector object</li>
<li><strong>while</strong>(enu.hasMoreElements())</li>
<li>{</li>
<li>System.<strong>out</strong>.println(" "+ enu.nextElement());</li>
<li>}</li>
</ol>
<p><strong>By using for-each</strong></p>
<p>It is mainly used to traverse array or collection elements. The advantage of for-each loop is that it eliminates the possibility of bugs and makes the code more readable.</p>
<p>Please refer below example so that you can understand better.</p>
<p><strong>Example:</strong></p>
<p><strong>traverse collection using for-each:</strong></p>
<ol>
<li>List&lt;String&gt; obj =<strong>new</strong>&nbsp;ArrayList&lt;String&gt;();</li>
<li>obj.add("Mango");</li>
<li>obj.add("Apple");</li>
<li>&nbsp;</li>
<li><strong>for</strong>(String kk:obj) ////obj is collection object</li>
<li>{</li>
<li>System.<strong>out</strong>.println("Elements :"+kk);</li>
<li>}</li>
</ol>
<p><strong>traverse array using for-each:</strong></p>
<ol>
<li><strong>int</strong>&nbsp;arr[]={12,13,14,44};</li>
<li>&nbsp;</li>
<li><strong>for</strong>(<strong>int</strong>&nbsp;i:arr){</li>
<li>System.<strong>out</strong>.println(i);</li>
<li>}</li>
<li><strong>By using for loop</strong></li>
</ol>
<p><strong>Example:</strong></p>
<ol>
<li>LinkedList obj=<strong>new</strong>&nbsp;LinkedList();</li>
<li>obj.add("Mango");</li>
<li>obj.add("Apple");</li>
<li>obj.add("Banana");</li>
<li>&nbsp;</li>
<li><strong>for</strong>(<strong>int</strong>&nbsp;i=0;i&lt;obj.size();i++) {</li>
<li>System.<strong>out</strong>.println(" "+obj.<strong>get</strong>(i));</li>
<li>}</li>
</ol>
<h4>ConcurrentHashMap in java</h4>
<p><a href="https://www.geeksforgeeks.org/concurrenthashmap-in-java/">https://www.geeksforgeeks.org/concurrenthashmap-in-java/</a></p>
<p><a href="https://java2blog.com/concurrenthashmap-in-java/">https://java2blog.com/concurrenthashmap-in-java/</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p><strong>ConcurrentHashMap</strong>&nbsp;ConcurrentHashMap class is introduced in JDK 1.5, which implements ConcurrentMap as well as Serializable interface also. ConcureentHashMap is enhancement of HashMap as we know that while dealing with Threads in our application HashMap is not a good choice because performance wise HashMap is not upto the mark.</p>
<p><strong>Key points of ConcurrentHashMap:</strong></p>
<p>It may have not have any null key or value.</p>
<ul>
<li>The underlined data structure for ConcurrentHashMap is Hashtable.</li>
<li>ConcurrentHashMap class is thread-safe i.e. multiple thread can operate on a single object without any complications.</li>
<li>At a time any number of threads are applicable for read operation without locking the ConcurrentHashMap object which is not there in HashMap.</li>
<li>In ConcurrentHashMap, the Object is divided into number of segments according to the concurrency level.</li>
<li>Default concurrency-level of ConcurrentHashMap is 16.</li>
<li>In ConcurrentHashMap, at a time any number of threads can perform retrieval operation but for updation in object, thread must lock the particular segment in which thread want to operate.This type of locking mechanism is known as&nbsp;<strong>Segment locking or bucket locking</strong>.Hence at a time 16 updation operations can be performed by threads.</li>
<li>null insertion is not possible in ConcurrentHashMap as key or value.</li>
</ul>
<p><strong>Constructors of ConcurrentHashMap:</strong></p>
<ol>
<li><strong>ConcurrentHashMap m=new ConcurrentHashMap();</strong>:Creates a new, empty map with a default initial capacity (16), load factor (0.75) and concurrencyLevel (16).</li>
<li><strong>ConcurrentHashMap m=new ConcurrentHashMap(int initialCapacity);</strong>:Creates a new, empty map with the specified initial capacity, and with default load factor (0.75) and concurrencyLevel (16).</li>
<li><strong>ConcurrentHashMap m=new ConcurrentHashMap(int initialCapacity, float loadFactor);</strong>:<br />Creates a new, empty map with the specified initial capacity and load factor and with the default concurrencyLevel (16).</li>
<li><strong>ConcurrentHashMap m=new ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel);</strong>:Creates a new, empty map with the specified initial capacity, load factor and concurrency level.</li>
<li><strong>ConcurrentHashMap m=new ConcurrentHashMap(Map m);</strong>:Creates a new map with the same mappings as the given map.</li>
</ol>
<p>// Java program to demonstrate working of ConcurrentHashMap</p>
<p>import java.util.concurrent.*;</p>
<p>class ConcurrentHashMapDemo {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap m = new ConcurrentHashMap();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.put(100, "Hello");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.put(101, "Geeks");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.put(102, "Geeks");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Here we cant add Hello because 101 key</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is already present in ConcurrentHashMap object</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.putIfAbsent(101, "Hello");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We can remove entry because 101 key</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// is associated with For value</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.remove(101, "Geeks");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now we can add Hello</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.putIfAbsent(103, "Hello");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// We cant replace Hello with For</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.replace(101, "Hello", "For");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(m);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
<p>Output:</p>
<p>{100=Hello, 102=Geeks, 103=Hello}</p>
<p>Notes :</p>
<ul>
<li>Hashtableis belongs to the Collection framework;&nbsp;ConcurrentHashMap&nbsp;belongs to the Executor framework.</li>
<li>Hashtableuses&nbsp;<strong>single lock</strong>&nbsp;for whole data.&nbsp;ConcurrentHashMap&nbsp;uses&nbsp;<strong>multiple locks</strong>&nbsp;on segment level (16 by default) instead of object level i.e. whole&nbsp;Map.</li>
<li>ConcurrentHashMaplocking is applied only for updates. In case of retrievals, it allows full concurrency, retrievals reflect the results of the most recently completed update operations. So reads can happen very fast while writes are done with a lock.</li>
<li>ConcurrentHashMapdoesn't throw a&nbsp;ConcurrentModificationException&nbsp;if one thread tries to modify it while another is iterating over it and does not allow null values.</li>
<li>ConcurrentHashMapreturns&nbsp;Iterator, which fails-safe (i.e. iterator will make a copy of the internal data structure) on concurrent modification.</li>
<li>ConcurrentHashMapuses a database shards logic (Segment&lt;K, V&gt;[] segments) is known as&nbsp;<strong>Concurrency-Level</strong>, i.e. divides the data into shards(segments) than puts locks on each shard (segment) instead of putting a single lock for whole data (Map). The default value is 16.</li>
</ul>
<p><strong>The following analogy helps you get understand the concept only(not logic)</strong></p>
<ul>
<li>Assume&nbsp;Hashtableand&nbsp;ConcurrentHashMap&nbsp;are two types of Homes.</li>
<li>Hashtablelocks home's main door.</li>
<li>ConcurrentHashMaplocks specific room door instead of main door.</li>
</ul>
<h4>Fail Fast and Fail Safe Iterators in Java</h4>
<p><a href="https://contribute.geeksforgeeks.org/iterators-in-java/">Iterators</a>&nbsp;in java are used to iterate over the Collection objects.Fail-Fast iterators immediately throw&nbsp;<em>ConcurrentModificationException</em>&nbsp;if there is&nbsp;<strong>structural modification</strong>&nbsp;of the collection. Structural modification means adding, removing any element from collection while a thread is iterating over that collection. Iterator on ArrayList, HashMap classes are some examples of fail-fast Iterator.<br />Fail-Safe iterators don&rsquo;t throw any exceptions if a collection is structurally modified while iterating over it. This is because, they operate on the clone of the collection, not on the original collection and that&rsquo;s why they are called fail-safe iterators. Iterator on CopyOnWriteArrayList, ConcurrentHashMap classes are examples of fail-safe Iterator.</p>
<p><strong>How Fail Fast Iterator works ?</strong></p>
<p>To know whether the collection is structurally modified or not, fail-fast iterators use an internal flag called&nbsp;<em>modCount</em>&nbsp;which is updated each time a collection is modified.Fail-fast iterators checks the&nbsp;<em>modCount</em>&nbsp;flag whenever it gets the next value (i.e. using&nbsp;<em>next()</em>&nbsp;method), and if it finds that the&nbsp;<em>modCount</em>&nbsp;has been modified after this iterator has been created, it throws&nbsp;<em>ConcurrentModificationException</em>.</p>
<p><strong>Important points of fail-fast iterators :&nbsp;</strong></p>
<ul>
<li>These iterators throw ConcurrentModificationException if a collection is modified while iterating over it.</li>
<li>They use original collection to traverse over the elements of the collection.</li>
<li>These iterators don&rsquo;t require extra memory.</li>
<li>Ex : Iterators returned by ArrayList, Vector, HashMap.</li>
</ul>
<p><strong>Note 1(from java-docs):&nbsp;</strong>The fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw&nbsp;<em>ConcurrentModificationException</em>&nbsp;on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.<br /><strong>Note 2 :&nbsp;</strong>If you remove an element via Iterator&nbsp;<em>remove()</em>&nbsp;method, exception will not be thrown. However, in case of removing via a particular collection&nbsp;<em>remove()</em>&nbsp;method,&nbsp;<em>ConcurrentModificationException</em>&nbsp;will be thrown. Below code snippet will demonstrate this:</p>
<p>&nbsp; &nbsp;</p>
<p><strong>Fail Safe Iterator</strong></p>
<p>First of all, there is no term as fail-safe given in many places as Java SE specifications does not use this term. I am using this term to demonstrate the difference between Fail Fast and Non-Fail Fast Iterator. These iterators make a copy of the internal collection (object array) and iterates over the copied collection. Any structural modification done to the iterator affects the copied collection,&nbsp;<strong>not original collection</strong>. So, original collection remains structurally&nbsp;<strong>unchanged</strong>.&nbsp;<br />&nbsp;</p>
<ul>
<li>Fail-safe iterators allow modifications of a collection while iterating over it.</li>
<li>These iterators don&rsquo;t throw any Exception if a collection is modified while iterating over it.</li>
<li>They use copy of original collection to traverse over the elements of the collection.</li>
<li>These iterators require extra memory for cloning of collection. Ex : ConcurrentHashMap, CopyOnWriteArrayList</li>
</ul>
<h1>Choosing the right Collection</h1>
<p><a href="http://www.javapractices.com/topic/TopicAction.do?Id=65">http://www.javapractices.com/topic/TopicAction.do?Id=65</a></p>
<p><strong>&nbsp;</strong></p>



</body>
</html>
