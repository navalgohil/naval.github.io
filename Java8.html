	<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>NG</title>
	<link href="CSS/bootstrap.min.css" rel="stylesheet">
	<link href="CSS/bootstrap-theme.min.css" rel="stylesheet">
	<link href="CSS/mystyle.css" rel="stylesheet">
	<link href="CSS/font-awesome.min.css" rel="stylesheet">
	<link href="CSS/bootstrap-social.css" rel="stylesheet"> 	

</head>
<body>

<!--=============================================================== NAVBAR =============================================================== -->
<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
	<div class="container">
		<div class="navbar-header">
			<a class="navbar-brand" href="master.html">NavalGohil</a>
			<button type="button" class="navbar-toggle collapsed"
				data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-control="navbar" >
				<span class="sr-only">Toggle Navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
		</div>
		<div id="navbar" class="navbar-collapse collapse">
			<ul class="nav navbar-nav">
				<li  class="active"><a href="master.html"><span class="glyphicon glyphicon-home" aria-hidden="true"></span> Home</a></li>
				<li><a onclick="window.open('https://html-online.com/editor/');" target="_blank">Editor</a></li>
				<li><a href="contact.html">Contact</a></li>					
			</ul>
		 </div>
	</div> <!-- container -->
</nav>

<!--=============================================================== HEADER =============================================================== -->

<!--=============================================================== MAIN BODY =============================================================== -->
<div class="container">


<h1>JAVA 8 Features</h1>
<h3><span style="background-color: #ffff00;"><strong>What are latest features introduced in Java 8?</strong></span></h3>
<p>The below features are introduced in Java 8:</p>
<ul>
<li><strong>Lambda Expressions&nbsp;</strong>&minus; a new language feature allowing treating actions as objects</li>
<li><strong>Method References</strong>&nbsp;&minus; enable defining Lambda Expressions by referring to methods directly using their names</li>
<li><strong><em>Optional</em></strong>&nbsp;&minus; special wrapper class used for expressing optionality</li>
<li><strong>Functional Interface</strong>&nbsp;&ndash; an interface with maximum one abstract method, implementation can be provided using a Lambda Expression</li>
<li><strong>Default methods</strong>&nbsp;&minus; give us the ability to add full implementations in interfaces besides abstract methods</li>
<li><strong>Nashorn, JavaScript Engine</strong>&nbsp;&minus; Java-based engine for executing and evaluating JavaScript code</li>
<li><strong><em>Stream</em></strong><strong>&nbsp;API</strong>&nbsp;&minus; a special iterator class that allows processing collections of objects in a functional manner</li>
<li><strong>Date API</strong>&nbsp;&minus; an improved, immutable JodaTime-inspired Date API</li>
</ul>
<h3><span style="background-color: #ffff00;"><strong>Name a few Java 8 annotations.</strong></span></h3>
<p><strong>@Functional Interface annotation</strong>:&nbsp;It was introduced in Java SE 8, which indicates that the type declaration is intended to be a functional interface as defined by the Java language specification.</p>
<p><strong>@Repeatable annotation</strong>: Introduced in Java SE 8, @Repeatable annotation indicates that the marked annotation can be applied many times to the same declaration or type use.</p>
<h3><strong><span style="background-color: #ffff00;">Distinguish between a predicate and a function</span>.</strong></h3>
<p>A&nbsp;<strong>predicate</strong>&nbsp;takes one argument and returns a Boolean value.</p>
<p>A&nbsp;<strong>function</strong>&nbsp;takes one argument and returns an object.&nbsp;Both are useful for evaluating lambda expressions.</p>
<h3><span style="background-color: #ffff00;"><strong>What Is a Lambda Expression and What Is It Used for</strong></span></h3>
<p>In very simple terms, a lambda expression is a function that can be referenced and passed around as an object.</p>
<p>Lambda expressions introduce functional style processing in Java and facilitate the writing of compact and easy-to-read code.</p>
<p>Because of this, lambda expressions are a natural replacement for anonymous classes as method arguments. One of their main uses is to define inline implementations of functional interfaces.</p>
<p><strong>Explain the Syntax and Characteristics of a Lambda Expression</strong></p>
<p>A lambda expression consists of two parts: the parameter part and the expressions part separated by a forward arrow as below:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="934">
<p>params -&gt; expressions</p>
</td>
</tr>
</tbody>
</table>
<p>Any lambda expression has the following characteristics:</p>
<ul>
<li><strong>Optional type declaration</strong>&nbsp;&ndash; when declaring the parameters on the left-hand side of the lambda, we don't need to declare their types as the compiler can infer them from their values. So&nbsp;<em>int param -&gt; &hellip;</em>&nbsp;and&nbsp;<em>param -&gt;&hellip;</em>&nbsp;are all valid</li>
<li><strong>Optional parentheses</strong>&nbsp;&ndash; when only a single parameter is declared, we don't need to place it in parentheses. This means&nbsp;<em>param -&gt; &hellip;</em>&nbsp;and&nbsp;<em>(param) -&gt; &hellip;</em>&nbsp;are all valid. But when more than one parameter is declared, parentheses are required</li>
<li><strong>Optional curly braces</strong>&nbsp;&ndash; when the expressions part only has a single statement, there is no need for curly braces. This means that&nbsp;<em>param &ndash; &gt; statement</em>&nbsp;and&nbsp;<em>param &ndash; &gt; {statement;}</em>&nbsp;are all valid. But curly braces are required when there is more than one statement</li>
<li><strong>Optional return statement</strong>&nbsp;&ndash; when the expression returns a value and it is wrapped inside curly braces, then we don't need a return statement. That means&nbsp;<em>(a, b) &ndash; &gt; {return a+b;}</em>&nbsp;and&nbsp;<em>(a, b) &ndash; &gt; {a+b;}</em>&nbsp;are both valid</li>
</ul>
<h3><span style="background-color: #ffff00;"><strong>What Is a Method Reference?</strong></span></h3>
<p>A method reference is a Java 8 construct that can be used for referencing a method without invoking it. It is used for treating methods as Lambda Expressions. They only work as syntactic sugar to reduce the verbosity of some lambdas. This way, the following code:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="935">
<p>(o) -&gt; o.toString();</p>
</td>
</tr>
</tbody>
</table>
<p>can become:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="935">
<p>Object::toString();</p>
</td>
</tr>
</tbody>
</table>
<p>A method reference can be identified by a double colon separating a class or object name and the name of the method. It has different variations such as constructor reference:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="935">
<p>String::new;</p>
</td>
</tr>
</tbody>
</table>
<p>Static method reference:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="935">
<p>String::valueOf;</p>
</td>
</tr>
</tbody>
</table>
<p>Bound instance method reference:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="935">
<p>str::toString;</p>
</td>
</tr>
</tbody>
</table>
<p>Unbound instance method reference:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
</td>
<td width="935">
<p>String::toString;</p>
</td>
</tr>
</tbody>
</table>
<p><span style="background-color: #ffff00;"><strong>What is the Optional class in java?</strong></span><br /><br />Java SE 8 introduces a new class in the util package i.e java.util.Optional. In a nutshell, you can view Optional as a single value container that either contains the value or not (then it is called as empty).<br />It is used to avoid NullPointerException. This Optional class concept is inspired by Haskell and Scala.<br /><br /><strong>Example of Optional Class</strong><br /><br />a. Here is an Empty Optional<br /><br /></p>
<div>
<pre>Optional&lt;Soundcard&gt;  sc = Optional.empty();
</pre>
</div>
<p><br />b. Here is an Optional with a non-null value<br /><br /></p>
<div>
<pre>Soundcard soundcard = new Soundcard();

Optional&lt;Soundcard&gt; sc = Optional.of(soundcard);</pre>
</div>
<p><br />The Optional class has various utility methods such as isPresent() which help coders to avoid making use of null value checks.</p>
<h3><span style="background-color: #ffff00;"><strong>What Is&nbsp;</strong><em>Optional</em><strong>? How Can It Be Used?</strong></span></h3>
<p><em>Optional</em>&nbsp;is a new class in Java 8 that encapsulates an optional value i.e. a value that is either there or not. It is a wrapper around an object, and you can think of it as a container of zero or one element.</p>
<p><em>Optional</em>&nbsp;has a special&nbsp;<em>Optional.empty()</em>&nbsp;value instead of wrapped&nbsp;<em>null</em>. Thus it can be used instead of a nullable value to get rid of&nbsp;<em>NullPointerException</em>&nbsp;in many cases.</p>
<p>You can read a dedicated article about&nbsp;<em>Optional</em>&nbsp;<a href="https://www.baeldung.com/java-optional">here</a>.</p>
<p>The main purpose of&nbsp;<em>Optional</em>, as designed by its creators, was to be a return type of methods that previously would return&nbsp;<em>null</em>. Such methods would require you to write boilerplate code to check the return value and sometimes could forget to do a defensive check. In Java 8, an&nbsp;<em>Optional</em>&nbsp;return type explicitly requires you to handle null or non-null wrapped values differently.</p>
<p>For instance, the&nbsp;<em>Stream.min()</em>&nbsp;method calculates the minimum value in a stream of values. But what if the stream is empty? If it was not for&nbsp;<em>Optional</em>, the method would return&nbsp;<em>null&nbsp;</em>or throw an exception.</p>
<p>But it returns an&nbsp;<em>Optional</em>&nbsp;value which may be&nbsp;<em>Optional.empty()</em>&nbsp;(the second case). This allows us to easily handle such case:</p>
<table style="width: 962px;" width="968">
<tbody>
<tr>
<td style="width: 952px;">
<p>int min1 = Arrays.stream(new int[]{1, 2, 3, 4, 5})</p>
<p>&nbsp;&nbsp;.min()</p>
<p>&nbsp;&nbsp;.orElse(0);</p>
<p>assertEquals(1, min1);</p>
<p>int min2 = Arrays.stream(new int[]{})</p>
<p>&nbsp;&nbsp;.min()</p>
<p>&nbsp;&nbsp;.orElse(0);</p>
<p>assertEquals(0, min2);</p>
</td>
</tr>
</tbody>
</table>
<h3><strong>What Is a Functional Interface? What Are the Rules of Defining a Functional Interface?</strong></h3>
<p>A functional interface is an interface with no more, no less but one single abstract method (<em>default</em>&nbsp;methods do not count).</p>
<p>Where an instance of such interface is required, a Lambda Expression can be used instead. More formally put:&nbsp;<em>Functional interfaces</em>&nbsp;provide target types for lambda expressions and method references.</p>
<p>The arguments and return type of such expression directly match those of the single abstract method.</p>
<p>For instance, the&nbsp;<em>Runnable</em>&nbsp;interface is a functional interface, so instead of:</p>
<table style="width: 962px; height: 174px;" width="968">
<tbody>
<tr style="height: 174px;">
<td style="width: 952px; height: 174px;">
<p>Thread thread = new Thread(new Runnable() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public void run() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Hello World!");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>});</p>
</td>
</tr>
</tbody>
</table>
<p>you could simply do:</p>
<table style="width: 962px;" width="968">
<tbody>
<tr>
<td style="width: 952px;">
<p>Thread thread = new Thread(() -&gt; System.out.println("Hello World!"));</p>
</td>
</tr>
</tbody>
</table>
<p>Functional interfaces are usually annotated with the&nbsp;<em>@FunctionalInterface</em>&nbsp;annotation &ndash; which is informative and does not affect the semantics.</p>
<p><strong>Describe Some of the Functional Interfaces in the Standard Library.</strong></p>
<p>There are a lot of functional interfaces in the&nbsp;<em>java.util.function</em>&nbsp;package, the more common ones include but not limited to:</p>
<ul>
<li><em>Function</em>&nbsp;&ndash; it takes one argument and returns a result</li>
<li><em>Consumer</em>&nbsp;&ndash; it takes one argument and returns no result (represents a side effect)</li>
<li><em>Supplier</em>&nbsp;&ndash; it takes not argument and returns a result</li>
<li><em>Predicate</em>&nbsp;&ndash; it takes one argument and returns a boolean</li>
<li><em>BiFunction</em>&nbsp;&ndash; it takes two arguments and returns a result</li>
<li><em>BinaryOperator</em>&nbsp;&ndash; it is similar to a&nbsp;<em>BiFunction</em>, taking two arguments and returning a result. The two arguments and the result are all of the same types</li>
<li><em>UnaryOperator</em>&nbsp;&ndash; it is similar to a&nbsp;<em>Function</em>, taking a single argument and returning a result of the same type</li>
</ul>
<h3><strong>What Is a Default Method and When Do We Use It?</strong></h3>
<p>A default method is a method with an implementation &ndash; which can be found in an interface.</p>
<p>We can use a default method to add a new functionality to an interface while maintaining backward compatibility with classes that are already implementing the interface:</p>
<table width="968">
<tbody>
<tr>
<td>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
</td>
<td width="934">
<p>public interface Vehicle {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;public void move();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;default void hoot() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("peep!");</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>Usually, when a new abstract method is added to an interface, all implementing classes will break until they implement the new abstract method. In Java 8, this problem has been solved by the use of default method.</p>
<p>For example,&nbsp;<em>Collection</em>&nbsp;interface does not have&nbsp;<em>forEach</em>&nbsp;method declaration. Thus, adding such method would simply break the whole collections API.</p>
<p>Java 8 introduces default method so that&nbsp;<em>Collection</em>&nbsp;interface can have a default implementation of&nbsp;<em>forEach</em>&nbsp;method without requiring the classes implementing this interface to implement the same.</p>
<h4><span style="background-color: #ffff00;"><strong>Stream In Java</strong></span></h4>
<p>Introduced in Java 8, the Stream API is used to process collections of objects. A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result.<br />The features of Java stream are &ndash;</p>
<ul>
<li>A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.</li>
<li>Streams don&rsquo;t change the original data structure, they only provide the result as per the pipelined methods.</li>
<li>Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.</li>
</ul>
<p>Different Operations On Streams-<br /><strong>Intermediate Operations:</strong></p>
<ol>
<li><strong>map:&nbsp;</strong>The map method is used to returns a stream consisting of the results of applying the given function to the elements of this stream.<br />List number = Arrays.asList(2,3,4,5);<br />List square = number.stream().map(x-&gt;x*x).collect(Collectors.toList());</li>
<li><strong>filter:</strong>The filter method is used to select elements as per the Predicate passed as argument.<br />List names = Arrays.asList("Reflection","Collection","Stream");<br />List result = names.stream().filter(s-&gt;s.startsWith("S")).collect(Collectors.toList());</li>
<li><strong>sorted:</strong>The sorted method is used to sort the stream.<br />List names = Arrays.asList("Reflection","Collection","Stream");<br />List result = names.stream().sorted().collect(Collectors.toList());</li>
</ol>
<p><strong>Terminal Operations:</strong></p>
<ol>
<li><strong>collect:</strong>The collect method is used to return the result of the intermediate operations performed on the stream.<br />List number = Arrays.asList(2,3,4,5,3);<br />Set square = number.stream().map(x-&gt;x*x).collect(Collectors.toSet());</li>
<li><strong>forEach:</strong>The forEach method is used to iterate through every element of the stream.<br />List number = Arrays.asList(2,3,4,5);<br />stream().map(x-&gt;x*x).forEach(y-&gt;System.out.println(y));</li>
<li><strong>reduce:</strong>The reduce method is used to reduce the elements of a stream to a single value.<br />The reduce method takes a BinaryOperator as a parameter.</li>
</ol>
<p>List number = Arrays.asList(2,3,4,5);<br />int even = number.stream().filter(x-&gt;x%2==0).reduce(0,(ans,i)-&gt; ans+i);</p>
<p>Here ans variable is assigned 0 as the initial value and i is added to it .</p>
<p><strong>Important Points/Observations:</strong></p>
<ol>
<li>A stream consists of source followed by zero or more intermediate methods combined together (pipelined) and a terminal method to process the objects obtained from the source as per the methods described.</li>
<li>Stream is used to compute elements as per the pipelined methods without altering the original value of the object.</li>
</ol>
<p><span style="background-color: #ffff00;"><strong>What is the difference between Collection API and Stream API?</strong></span><br /><br /><a name="more"></a><strong>Differences between Collection API and Stream API are as follow :</strong><br /><br />1. Collection API was introduced in JDK 1.2 while Stream API is introduced in JDK 1.8<br />2. Collection objects are created eagerly while Stream API objects are created lazily.<br />3. Iterate and Consume elements at any number of times for the Collection object while iterate and consume elements only one time for the Stream object.</p>
<h3><span style="background-color: #ffff00;"><strong>What Is a Stream? How Does It Differ from a Collection?</strong></span></h3>
<p>In simple terms, a stream is an iterator whose role is to accept a set of actions to apply on each of the elements it contains.</p>
<p><em>The stream</em>&nbsp;represents a sequence of objects from a source such as a collection, which supports aggregate operations. They were designed to make collection processing simple and concise. Contrary to the collections, the logic of iteration is implemented inside the stream, so we can use methods like&nbsp;<em>map</em>&nbsp;and&nbsp;<em>flatMap</em>&nbsp;for performing a declarative processing.</p>
<p>Another difference is that the&nbsp;<em>Stream</em>&nbsp;API is fluent and allows pipelining:</p>
<table width="968">
<tbody>
<tr>
<td width="934">
<p>int sum = Arrays.stream(new int[]{1, 2, 3})</p>
<p>&nbsp;&nbsp;.filter(i -&gt; i &gt;= 2)</p>
<p>&nbsp;&nbsp;.map(i -&gt; i * 3)</p>
<p>&nbsp;&nbsp;.sum();</p>
</td>
</tr>
</tbody>
</table>
<p>And yet another important distinction from collections is that streams are inherently lazily loaded and processed.</p>
<p><span style="background-color: #ffff00;"><strong>What is Nashorn in java 8?</strong></span><br /><br />Nashorn is the latest javascript engine released with java8. Before JDK 8, the javascript engine was based on Mozilla Rhino.<br /><br />It provides better compliance with ECMA normalized javascript specifications and better runtime performance.</p>
<p><span style="background-color: #ffff00;"><strong>What are the issues of the old Date and Time APIs.&nbsp; Can you explain the new Date and Time APIs in java 8?</strong></span><br /><br />Prior to java 8, Old Date and Time API's are there. Let's find out what are the issues with them:<br /><br /><strong>Performance:</strong>&nbsp; Java 8 APIs are better in terms of performance than older Date and Time APIs.<br /><br /><strong>Standards:&nbsp;</strong>Java 8 Date and Time API&nbsp; comply with ISO standard, meanwhile, older java 8 Date and Time API were hard to understand and poorly designed.<br /><br /><strong>Thread-safe:&nbsp;</strong>Most frequently used java.util.Date is mutable and not thread-safe. New Java 8 Date and Time API are thread-safe.<br /><br />LocalDateTime, LocalDate, and LocalTime are few of the latest core API classes of java 8.</p>
<p><a href="https://javahungry.blogspot.com/2018/10/java-8-interview-questions-and-answers.html" target="_blank">https://javahungry.blogspot.com/2018/10/java-8-interview-questions-and-answers.html</a></p>
<h3><strong>&nbsp;</strong></h3>
<p>&nbsp;</p>


</div> <!-- B CONTAINER -->             

  
<!--=============================================================== FOOTER =============================================================== -->
<div class="footer row-footer">
	<div class="container">
		<div class="row">
			<div class="col-xs-12">
				
				<p align="Left"> <b>@Copyright 2019 Naval Gohil</b></p>
			</div>
		</div> <!-- F ROW 1 -->
	</div> <!-- F CONTAINER -->
</div> <!-- FOOTER -->

<script  src="JS/jquery-1.11.3.min.js" ></script>
<script  src="JS/bootstrap.min.js" ></script>
<script  src="https://cdn.datatables.net/1.12.1/js/jquery.dataTables.min.js"></script> 
<script type="text/javascript">
           $(document).ready(function() {
				$('#example').DataTable({
					pagingType: 'full_numbers',
				});
			});
			document.addEventListener('keydown', function() {
			  if (event.keyCode == 123) {
				alert("This function has been disabled to prevent you from stealing my code!");
				return false;
			  } else if (event.ctrlKey && event.shiftKey && event.keyCode == 73) {
				alert("This function has been disabled to prevent you from stealing my code!");
				return false;
			  } else if (event.ctrlKey && event.keyCode == 85) {
				alert("This function has been disabled to prevent you from stealing my code!");
				return false;
			  }
			}, false);

			if (document.addEventListener) {
			  document.addEventListener('contextmenu', function(e) {
				alert("This function has been disabled to prevent you from stealing my code!");
				e.preventDefault();
			  }, false);
			} else {
			  document.attachEvent('oncontextmenu', function() {
				alert("This function has been disabled to prevent you from stealing my code!");
				window.event.returnValue = false;
			  });
			}
</script>


</body>
</html>
